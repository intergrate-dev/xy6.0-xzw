/*

 /!*
 * JQuery zTree core 3.3
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2012-07-16
 *!/
 (function(k){var B,C,D,E,F,G,p={},H={},q={},L=0,I={treeId:"",treeObj:null,view:{addDiyDom:null,autoCancelSelected:!0,dblClickExpand:!0,expandSpeed:"fast",fontCss:{},nameIsHTML:!1,selectedMulti:!0,showIcon:!0,showLine:!0,showTitle:!0},data:{key:{children:"children",name:"name",title:"",url:"url"},simpleData:{enable:!1,idKey:"id",pIdKey:"pId",rootPId:null},keep:{parent:!1,leaf:!1}},async:{enable:!1,contentType:"application/x-www-form-urlencoded",type:"post",dataType:"text",url:"",autoParam:[],otherParam:[],
 dataFilter:null},callback:{beforeAsync:null,beforeClick:null,beforeRightClick:null,beforeMouseDown:null,beforeMouseUp:null,beforeExpand:null,beforeCollapse:null,beforeRemove:null,onAsyncError:null,onAsyncSuccess:null,onNodeCreated:null,onClick:null,onRightClick:null,onMouseDown:null,onMouseUp:null,onExpand:null,onCollapse:null,onRemove:null}},r=[function(b){var a=b.treeObj,c=e.event;a.unbind(c.NODECREATED);a.bind(c.NODECREATED,function(a,c,g){j.apply(b.callback.onNodeCreated,[a,c,g])});a.unbind(c.CLICK);
 a.bind(c.CLICK,function(a,c,g,l,e){j.apply(b.callback.onClick,[c,g,l,e])});a.unbind(c.EXPAND);a.bind(c.EXPAND,function(a,c,g){j.apply(b.callback.onExpand,[a,c,g])});a.unbind(c.COLLAPSE);a.bind(c.COLLAPSE,function(a,c,g){j.apply(b.callback.onCollapse,[a,c,g])});a.unbind(c.ASYNC_SUCCESS);a.bind(c.ASYNC_SUCCESS,function(a,c,g,l){j.apply(b.callback.onAsyncSuccess,[a,c,g,l])});a.unbind(c.ASYNC_ERROR);a.bind(c.ASYNC_ERROR,function(a,c,g,l,e,h){j.apply(b.callback.onAsyncError,[a,c,g,l,e,h])})}],s=[function(b){var a=
 i.getCache(b);a||(a={},i.setCache(b,a));a.nodes=[];a.doms=[]}],t=[function(b,a,c,d,f,g){if(c){var l=b.data.key.children;c.level=a;c.tId=b.treeId+"_"+ ++L;c.parentTId=d?d.tId:null;if(c[l]&&c[l].length>0){if(typeof c.open=="string")c.open=j.eqs(c.open,"true");c.open=!!c.open;c.isParent=!0;c.zAsync=!0}else{c.open=!1;if(typeof c.isParent=="string")c.isParent=j.eqs(c.isParent,"true");c.isParent=!!c.isParent;c.zAsync=!c.isParent}c.isFirstNode=f;c.isLastNode=g;c.getParentNode=function(){return i.getNodeCache(b,
 c.parentTId)};c.getPreNode=function(){return i.getPreNode(b,c)};c.getNextNode=function(){return i.getNextNode(b,c)};c.isAjaxing=!1;i.fixPIdKeyValue(b,c)}}],u=[function(b){var a=b.target,c=p[b.data.treeId],d="",f=null,g="",l="",h=null,m=null,k=null;if(j.eqs(b.type,"mousedown"))l="mousedown";else if(j.eqs(b.type,"mouseup"))l="mouseup";else if(j.eqs(b.type,"contextmenu"))l="contextmenu";else if(j.eqs(b.type,"click"))if(j.eqs(a.tagName,"span")&&a.getAttribute("treeNode"+e.id.SWITCH)!==null)d=a.parentNode.id,
 g="switchNode";else{if(k=j.getMDom(c,a,[{tagName:"a",attrName:"treeNode"+e.id.A}]))d=k.parentNode.id,g="clickNode"}else if(j.eqs(b.type,"dblclick")&&(l="dblclick",k=j.getMDom(c,a,[{tagName:"a",attrName:"treeNode"+e.id.A}])))d=k.parentNode.id,g="switchNode";if(l.length>0&&d.length==0&&(k=j.getMDom(c,a,[{tagName:"a",attrName:"treeNode"+e.id.A}])))d=k.parentNode.id;if(d.length>0)switch(f=i.getNodeCache(c,d),g){case "switchNode":f.isParent?j.eqs(b.type,"click")||j.eqs(b.type,"dblclick")&&j.apply(c.view.dblClickExpand,
 [c.treeId,f],c.view.dblClickExpand)?h=B:g="":g="";break;case "clickNode":h=C}switch(l){case "mousedown":m=D;break;case "mouseup":m=E;break;case "dblclick":m=F;break;case "contextmenu":m=G}return{stop:!1,node:f,nodeEventType:g,nodeEventCallback:h,treeEventType:l,treeEventCallback:m}}],v=[function(b){var a=i.getRoot(b);a||(a={},i.setRoot(b,a));a[b.data.key.children]=[];a.expandTriggerFlag=!1;a.curSelectedList=[];a.noSelection=!0;a.createdNodes=[]}],w=[],x=[],y=[],z=[],A=[],i={addNodeCache:function(b,
 a){i.getCache(b).nodes[a.tId]=a},addAfterA:function(b){x.push(b)},addBeforeA:function(b){w.push(b)},addInnerAfterA:function(b){z.push(b)},addInnerBeforeA:function(b){y.push(b)},addInitBind:function(b){r.push(b)},addInitCache:function(b){s.push(b)},addInitNode:function(b){t.push(b)},addInitProxy:function(b){u.push(b)},addInitRoot:function(b){v.push(b)},addNodesData:function(b,a,c){var d=b.data.key.children;a[d]||(a[d]=[]);if(a[d].length>0)a[d][a[d].length-1].isLastNode=!1,h.setNodeLineIcos(b,a[d][a[d].length-
 1]);a.isParent=!0;a[d]=a[d].concat(c)},addSelectedNode:function(b,a){var c=i.getRoot(b);i.isSelectedNode(b,a)||c.curSelectedList.push(a)},addCreatedNode:function(b,a){(b.callback.onNodeCreated||b.view.addDiyDom)&&i.getRoot(b).createdNodes.push(a)},addZTreeTools:function(b){A.push(b)},exSetting:function(b){k.extend(!0,I,b)},fixPIdKeyValue:function(b,a){b.data.simpleData.enable&&(a[b.data.simpleData.pIdKey]=a.parentTId?a.getParentNode()[b.data.simpleData.idKey]:b.data.simpleData.rootPId)},getAfterA:function(b,
 a,c){for(var d=0,f=x.length;d<f;d++)x[d].apply(this,arguments)},getBeforeA:function(b,a,c){for(var d=0,f=w.length;d<f;d++)w[d].apply(this,arguments)},getInnerAfterA:function(b,a,c){for(var d=0,f=z.length;d<f;d++)z[d].apply(this,arguments)},getInnerBeforeA:function(b,a,c){for(var d=0,f=y.length;d<f;d++)y[d].apply(this,arguments)},getCache:function(b){return q[b.treeId]},getNextNode:function(b,a){if(!a)return null;for(var c=b.data.key.children,d=a.parentTId?a.getParentNode():i.getRoot(b),f=0,g=d[c].length-
 1;f<=g;f++)if(d[c][f]===a)return f==g?null:d[c][f+1];return null},getNodeByParam:function(b,a,c,d){if(!a||!c)return null;for(var f=b.data.key.children,g=0,l=a.length;g<l;g++){if(a[g][c]==d)return a[g];var e=i.getNodeByParam(b,a[g][f],c,d);if(e)return e}return null},getNodeCache:function(b,a){if(!a)return null;var c=q[b.treeId].nodes[a];return c?c:null},getNodes:function(b){return i.getRoot(b)[b.data.key.children]},getNodesByParam:function(b,a,c,d){if(!a||!c)return[];for(var f=b.data.key.children,
 g=[],l=0,e=a.length;l<e;l++)a[l][c]==d&&g.push(a[l]),g=g.concat(i.getNodesByParam(b,a[l][f],c,d));return g},getNodesByParamFuzzy:function(b,a,c,d){if(!a||!c)return[];for(var f=b.data.key.children,g=[],l=0,e=a.length;l<e;l++)typeof a[l][c]=="string"&&a[l][c].indexOf(d)>-1&&g.push(a[l]),g=g.concat(i.getNodesByParamFuzzy(b,a[l][f],c,d));return g},getNodesByFilter:function(b,a,c,d,f){if(!a)return d?null:[];for(var g=b.data.key.children,l=d?null:[],e=0,h=a.length;e<h;e++){if(j.apply(c,[a[e],f],!1)){if(d)return a[e];
 l.push(a[e])}var k=i.getNodesByFilter(b,a[e][g],c,d,f);if(d&&k)return k;l=d?k:l.concat(k)}return l},getPreNode:function(b,a){if(!a)return null;for(var c=b.data.key.children,d=a.parentTId?a.getParentNode():i.getRoot(b),f=0,g=d[c].length;f<g;f++)if(d[c][f]===a)return f==0?null:d[c][f-1];return null},getRoot:function(b){return b?H[b.treeId]:null},getSetting:function(b){return p[b]},getSettings:function(){return p},getTitleKey:function(b){return b.data.key.title===""?b.data.key.name:b.data.key.title},
 getZTreeTools:function(b){return(b=this.getRoot(this.getSetting(b)))?b.treeTools:null},initCache:function(b){for(var a=0,c=s.length;a<c;a++)s[a].apply(this,arguments)},initNode:function(b,a,c,d,f,g){for(var l=0,e=t.length;l<e;l++)t[l].apply(this,arguments)},initRoot:function(b){for(var a=0,c=v.length;a<c;a++)v[a].apply(this,arguments)},isSelectedNode:function(b,a){for(var c=i.getRoot(b),d=0,f=c.curSelectedList.length;d<f;d++)if(a===c.curSelectedList[d])return!0;return!1},removeNodeCache:function(b,
 a){var c=b.data.key.children;if(a[c])for(var d=0,f=a[c].length;d<f;d++)arguments.callee(b,a[c][d]);delete i.getCache(b).nodes[a.tId]},removeSelectedNode:function(b,a){for(var c=i.getRoot(b),d=0,f=c.curSelectedList.length;d<f;d++)if(a===c.curSelectedList[d]||!i.getNodeCache(b,c.curSelectedList[d].tId))c.curSelectedList.splice(d,1),d--,f--},setCache:function(b,a){q[b.treeId]=a},setRoot:function(b,a){H[b.treeId]=a},setZTreeTools:function(b,a){for(var c=0,d=A.length;c<d;c++)A[c].apply(this,arguments)},
 transformToArrayFormat:function(b,a){if(!a)return[];var c=b.data.key.children,d=[];if(j.isArray(a))for(var f=0,g=a.length;f<g;f++)d.push(a[f]),a[f][c]&&(d=d.concat(i.transformToArrayFormat(b,a[f][c])));else d.push(a),a[c]&&(d=d.concat(i.transformToArrayFormat(b,a[c])));return d},transformTozTreeFormat:function(b,a){var c,d,f=b.data.simpleData.idKey,g=b.data.simpleData.pIdKey,l=b.data.key.children;if(!f||f==""||!a)return[];if(j.isArray(a)){var e=[],h=[];for(c=0,d=a.length;c<d;c++)h[a[c][f]]=a[c];for(c=
 0,d=a.length;c<d;c++)h[a[c][g]]&&a[c][f]!=a[c][g]?(h[a[c][g]][l]||(h[a[c][g]][l]=[]),h[a[c][g]][l].push(a[c])):e.push(a[c]);return e}else return[a]}},n={bindEvent:function(b){for(var a=0,c=r.length;a<c;a++)r[a].apply(this,arguments)},bindTree:function(b){var a={treeId:b.treeId},b=b.treeObj;b.unbind("click",n.proxy);b.bind("click",a,n.proxy);b.unbind("dblclick",n.proxy);b.bind("dblclick",a,n.proxy);b.unbind("mouseover",n.proxy);b.bind("mouseover",a,n.proxy);b.unbind("mouseout",n.proxy);b.bind("mouseout",
 a,n.proxy);b.unbind("mousedown",n.proxy);b.bind("mousedown",a,n.proxy);b.unbind("mouseup",n.proxy);b.bind("mouseup",a,n.proxy);b.unbind("contextmenu",n.proxy);b.bind("contextmenu",a,n.proxy)},doProxy:function(b){for(var a=[],c=0,d=u.length;c<d;c++){var f=u[c].apply(this,arguments);a.push(f);if(f.stop)break}return a},proxy:function(b){var a=i.getSetting(b.data.treeId);if(!j.uCanDo(a,b))return!0;for(var c=n.doProxy(b),d=!0,f=!1,g=0,l=c.length;g<l;g++){var e=c[g];e.nodeEventCallback&&(f=!0,d=e.nodeEventCallback.apply(e,
 [b,e.node])&&d);e.treeEventCallback&&(f=!0,d=e.treeEventCallback.apply(e,[b,e.node])&&d)}try{f&&k("input:focus").length==0&&j.noSel(a)}catch(h){}return d}};B=function(b,a){var c=p[b.data.treeId];if(a.open){if(j.apply(c.callback.beforeCollapse,[c.treeId,a],!0)==!1)return!0}else if(j.apply(c.callback.beforeExpand,[c.treeId,a],!0)==!1)return!0;i.getRoot(c).expandTriggerFlag=!0;h.switchNode(c,a);return!0};C=function(b,a){var c=p[b.data.treeId],d=c.view.autoCancelSelected&&b.ctrlKey&&i.isSelectedNode(c,
 a)?0:c.view.autoCancelSelected&&b.ctrlKey&&c.view.selectedMulti?2:1;if(j.apply(c.callback.beforeClick,[c.treeId,a,d],!0)==!1)return!0;d===0?h.cancelPreSelectedNode(c,a):h.selectNode(c,a,d===2);c.treeObj.trigger(e.event.CLICK,[b,c.treeId,a,d]);return!0};D=function(b,a){var c=p[b.data.treeId];j.apply(c.callback.beforeMouseDown,[c.treeId,a],!0)&&j.apply(c.callback.onMouseDown,[b,c.treeId,a]);return!0};E=function(b,a){var c=p[b.data.treeId];j.apply(c.callback.beforeMouseUp,[c.treeId,a],!0)&&j.apply(c.callback.onMouseUp,
 [b,c.treeId,a]);return!0};F=function(b,a){var c=p[b.data.treeId];j.apply(c.callback.beforeDblClick,[c.treeId,a],!0)&&j.apply(c.callback.onDblClick,[b,c.treeId,a]);return!0};G=function(b,a){var c=p[b.data.treeId];j.apply(c.callback.beforeRightClick,[c.treeId,a],!0)&&j.apply(c.callback.onRightClick,[b,c.treeId,a]);return typeof c.callback.onRightClick!="function"};var j={apply:function(b,a,c){return typeof b=="function"?b.apply(K,a?a:[]):c},canAsync:function(b,a){var c=b.data.key.children;return b.async.enable&&
 a&&a.isParent&&!(a.zAsync||a[c]&&a[c].length>0)},clone:function(b){var a;if(b instanceof Array){a=[];for(var c=b.length;c--;)a[c]=arguments.callee(b[c]);return a}else if(typeof b=="function")return b;else if(b instanceof Object){a={};for(c in b)a[c]=arguments.callee(b[c]);return a}else return b},eqs:function(b,a){return b.toLowerCase()===a.toLowerCase()},isArray:function(b){return Object.prototype.toString.apply(b)==="[object Array]"},getMDom:function(b,a,c){if(!a)return null;for(;a&&a.id!==b.treeId;){for(var d=
 0,f=c.length;a.tagName&&d<f;d++)if(j.eqs(a.tagName,c[d].tagName)&&a.getAttribute(c[d].attrName)!==null)return a;a=a.parentNode}return null},noSel:function(b){if(i.getRoot(b).noSelection)try{window.getSelection?window.getSelection().removeAllRanges():document.selection.empty()}catch(a){}},uCanDo:function(){return!0}},h={addNodes:function(b,a,c,d){if(!b.data.keep.leaf||!a||a.isParent)if(j.isArray(c)||(c=[c]),b.data.simpleData.enable&&(c=i.transformTozTreeFormat(b,c)),a){var f=k("#"+a.tId+e.id.SWITCH),
 g=k("#"+a.tId+e.id.ICON),l=k("#"+a.tId+e.id.UL);if(!a.open)h.replaceSwitchClass(a,f,e.folder.CLOSE),h.replaceIcoClass(a,g,e.folder.CLOSE),a.open=!1,l.css({display:"none"});i.addNodesData(b,a,c);h.createNodes(b,a.level+1,c,a);d||h.expandCollapseParentNode(b,a,!0)}else i.addNodesData(b,i.getRoot(b),c),h.createNodes(b,0,c,null)},appendNodes:function(b,a,c,d,f,g){if(!c)return[];for(var e=[],j=b.data.key.children,k=0,n=c.length;k<n;k++){var o=c[k];if(f){var p=(d?d:i.getRoot(b))[j].length==c.length&&k==
 0;i.initNode(b,a,o,d,p,k==c.length-1,g);i.addNodeCache(b,o)}p=[];o[j]&&o[j].length>0&&(p=h.appendNodes(b,a+1,o[j],o,f,g&&o.open));g&&(h.makeDOMNodeMainBefore(e,b,o),h.makeDOMNodeLine(e,b,o),i.getBeforeA(b,o,e),h.makeDOMNodeNameBefore(e,b,o),i.getInnerBeforeA(b,o,e),h.makeDOMNodeIcon(e,b,o),i.getInnerAfterA(b,o,e),h.makeDOMNodeNameAfter(e,b,o),i.getAfterA(b,o,e),o.isParent&&o.open&&h.makeUlHtml(b,o,e,p.join("")),h.makeDOMNodeMainAfter(e,b,o),i.addCreatedNode(b,o))}return e},appendParentULDom:function(b,
 a){var c=[],d=k("#"+a.tId),f=k("#"+a.tId+e.id.UL),g=h.appendNodes(b,a.level+1,a[b.data.key.children],a,!1,!0);h.makeUlHtml(b,a,c,g.join(""));!d.get(0)&&a.parentTId&&(h.appendParentULDom(b,a.getParentNode()),d=k("#"+a.tId));f.get(0)&&f.remove();d.append(c.join(""))},asyncNode:function(b,a,c,d){var f,g;if(a&&!a.isParent)return j.apply(d),!1;else if(a&&a.isAjaxing)return!1;else if(j.apply(b.callback.beforeAsync,[b.treeId,a],!0)==!1)return j.apply(d),!1;if(a)a.isAjaxing=!0,k("#"+a.tId+e.id.ICON).attr({style:"",
 "class":"button ico_loading"});var l=b.async.contentType=="application/json",i=l?"{":"",m="";for(f=0,g=b.async.autoParam.length;a&&f<g;f++){var n=b.async.autoParam[f].split("="),o=n;n.length>1&&(o=n[1],n=n[0]);l?(m=typeof a[n]=="string"?'"':"",i+='"'+o+('":'+m+a[n]).replace(/'/g,"\\'")+m+","):i+=o+("="+a[n]).replace(/&/g,"%26")+"&"}if(j.isArray(b.async.otherParam))for(f=0,g=b.async.otherParam.length;f<g;f+=2)l?(m=typeof b.async.otherParam[f+1]=="string"?'"':"",i+='"'+b.async.otherParam[f]+('":'+m+
 b.async.otherParam[f+1]).replace(/'/g,"\\'")+m+","):i+=b.async.otherParam[f]+("="+b.async.otherParam[f+1]).replace(/&/g,"%26")+"&";else for(var p in b.async.otherParam)l?(m=typeof b.async.otherParam[p]=="string"?'"':"",i+='"'+p+('":'+m+b.async.otherParam[p]).replace(/'/g,"\\'")+m+","):i+=p+("="+b.async.otherParam[p]).replace(/&/g,"%26")+"&";i.length>1&&(i=i.substring(0,i.length-1));l&&(i+="}");k.ajax({contentType:b.async.contentType,type:b.async.type,url:j.apply(b.async.url,[b.treeId,a],b.async.url),
 data:i,dataType:b.async.dataType,success:function(f){var g=[];try{g=!f||f.length==0?[]:typeof f=="string"?eval("("+f+")"):f}catch(l){}if(a)a.isAjaxing=null,a.zAsync=!0;h.setNodeLineIcos(b,a);g&&g!==""?(g=j.apply(b.async.dataFilter,[b.treeId,a,g],g),h.addNodes(b,a,g?j.clone(g):[],!!c)):h.addNodes(b,a,[],!!c);b.treeObj.trigger(e.event.ASYNC_SUCCESS,[b.treeId,a,f]);j.apply(d)},error:function(c,d,f){if(a)a.isAjaxing=null;h.setNodeLineIcos(b,a);b.treeObj.trigger(e.event.ASYNC_ERROR,[b.treeId,a,c,d,f])}});
 return!0},cancelPreSelectedNode:function(b,a){for(var c=i.getRoot(b).curSelectedList,d=c.length-1;d>=0;d--)if(!a||a===c[d])if(k("#"+c[d].tId+e.id.A).removeClass(e.node.CURSELECTED),h.setNodeName(b,c[d]),a){i.removeSelectedNode(b,a);break}if(!a)i.getRoot(b).curSelectedList=[]},createNodeCallback:function(b){if(b.callback.onNodeCreated||b.view.addDiyDom)for(var a=i.getRoot(b);a.createdNodes.length>0;){var c=a.createdNodes.shift();j.apply(b.view.addDiyDom,[b.treeId,c]);b.callback.onNodeCreated&&b.treeObj.trigger(e.event.NODECREATED,
 [b.treeId,c])}},createNodes:function(b,a,c,d){if(c&&c.length!=0){var f=i.getRoot(b),g=b.data.key.children,g=!d||d.open||!!k("#"+d[g][0].tId).get(0);f.createdNodes=[];a=h.appendNodes(b,a,c,d,!0,g);d?(d=k("#"+d.tId+e.id.UL),d.get(0)&&d.append(a.join(""))):b.treeObj.append(a.join(""));h.createNodeCallback(b)}},expandCollapseNode:function(b,a,c,d,f){var g=i.getRoot(b),l=b.data.key.children;if(a){if(g.expandTriggerFlag){var J=f,f=function(){J&&J();a.open?b.treeObj.trigger(e.event.EXPAND,[b.treeId,a]):
 b.treeObj.trigger(e.event.COLLAPSE,[b.treeId,a])};g.expandTriggerFlag=!1}if(a.open==c)j.apply(f,[]);else{if(!a.open&&a.isParent&&(!k("#"+a.tId+e.id.UL).get(0)||a[l]&&a[l].length>0&&!k("#"+a[l][0].tId).get(0)))h.appendParentULDom(b,a),h.createNodeCallback(b);var c=k("#"+a.tId+e.id.UL),g=k("#"+a.tId+e.id.SWITCH),m=k("#"+a.tId+e.id.ICON);a.isParent?(a.open=!a.open,a.iconOpen&&a.iconClose&&m.attr("style",h.makeNodeIcoStyle(b,a)),a.open?(h.replaceSwitchClass(a,g,e.folder.OPEN),h.replaceIcoClass(a,m,e.folder.OPEN),
 d==!1||b.view.expandSpeed==""?(c.show(),j.apply(f,[])):a[l]&&a[l].length>0?c.slideDown(b.view.expandSpeed,f):(c.show(),j.apply(f,[]))):(h.replaceSwitchClass(a,g,e.folder.CLOSE),h.replaceIcoClass(a,m,e.folder.CLOSE),d==!1||b.view.expandSpeed==""||!(a[l]&&a[l].length>0)?(c.hide(),j.apply(f,[])):c.slideUp(b.view.expandSpeed,f))):j.apply(f,[])}}else j.apply(f,[])},expandCollapseParentNode:function(b,a,c,d,f){a&&(a.parentTId?(h.expandCollapseNode(b,a,c,d),a.parentTId&&h.expandCollapseParentNode(b,a.getParentNode(),
 c,d,f)):h.expandCollapseNode(b,a,c,d,f))},expandCollapseSonNode:function(b,a,c,d,f){var g=i.getRoot(b),e=b.data.key.children,g=a?a[e]:g[e],e=a?!1:d,j=i.getRoot(b).expandTriggerFlag;i.getRoot(b).expandTriggerFlag=!1;if(g)for(var k=0,n=g.length;k<n;k++)g[k]&&h.expandCollapseSonNode(b,g[k],c,e);i.getRoot(b).expandTriggerFlag=j;h.expandCollapseNode(b,a,c,d,f)},makeDOMNodeIcon:function(b,a,c){var d=a.data.key.name,d=a.view.nameIsHTML?c[d]:c[d].replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
 b.push("<span id='",c.tId,e.id.ICON,"' title='' treeNode",e.id.ICON," class='",h.makeNodeIcoClass(a,c),"' style='",h.makeNodeIcoStyle(a,c),"'></span><span id='",c.tId,e.id.SPAN,"'>",d,"</span>")},makeDOMNodeLine:function(b,a,c){b.push("<span id='",c.tId,e.id.SWITCH,"' title='' class='",h.makeNodeLineClass(a,c),"' treeNode",e.id.SWITCH,"></span>")},makeDOMNodeMainAfter:function(b){b.push("</li>")},makeDOMNodeMainBefore:function(b,a,c){b.push("<li id='",c.tId,"' class='level",c.level,"' tabindex='0' hidefocus='true' treenode>")},
 makeDOMNodeNameAfter:function(b){b.push("</a>")},makeDOMNodeNameBefore:function(b,a,c){var d=i.getTitleKey(a),f=h.makeNodeUrl(a,c),g=h.makeNodeFontCss(a,c),l=[],k;for(k in g)l.push(k,":",g[k],";");b.push("<a id='",c.tId,e.id.A,"' class='level",c.level,"' treeNode",e.id.A,' onclick="',c.click||"",'" ',f!=null&&f.length>0?"href='"+f+"'":""," target='",h.makeNodeTarget(c),"' style='",l.join(""),"'");j.apply(a.view.showTitle,[a.treeId,c],a.view.showTitle)&&c[d]&&b.push("title='",c[d].replace(/'/g,"&#39;").replace(/</g,
 "&lt;").replace(/>/g,"&gt;"),"'");b.push(">")},makeNodeFontCss:function(b,a){var c=j.apply(b.view.fontCss,[b.treeId,a],b.view.fontCss);return c&&typeof c!="function"?c:{}},makeNodeIcoClass:function(b,a){var c=["ico"];a.isAjaxing||(c[0]=(a.iconSkin?a.iconSkin+"_":"")+c[0],a.isParent?c.push(a.open?e.folder.OPEN:e.folder.CLOSE):c.push(e.folder.DOCU));return"button "+c.join("_")},makeNodeIcoStyle:function(b,a){var c=[];if(!a.isAjaxing){var d=a.isParent&&a.iconOpen&&a.iconClose?a.open?a.iconOpen:a.iconClose:
 a.icon;d&&c.push("background:url(",d,") 0 0 no-repeat;");(b.view.showIcon==!1||!j.apply(b.view.showIcon,[b.treeId,a],!0))&&c.push("width:0px;height:0px;")}return c.join("")},makeNodeLineClass:function(b,a){var c=[];b.view.showLine?a.level==0&&a.isFirstNode&&a.isLastNode?c.push(e.line.ROOT):a.level==0&&a.isFirstNode?c.push(e.line.ROOTS):a.isLastNode?c.push(e.line.BOTTOM):c.push(e.line.CENTER):c.push(e.line.NOLINE);a.isParent?c.push(a.open?e.folder.OPEN:e.folder.CLOSE):c.push(e.folder.DOCU);return h.makeNodeLineClassEx(a)+
 c.join("_")},makeNodeLineClassEx:function(b){return"button level"+b.level+" switch "},makeNodeTarget:function(b){return b.target||"_blank"},makeNodeUrl:function(b,a){var c=b.data.key.url;return a[c]?a[c]:null},makeUlHtml:function(b,a,c,d){c.push("<ul id='",a.tId,e.id.UL,"' class='level",a.level," ",h.makeUlLineClass(b,a),"' style='display:",a.open?"block":"none","'>");c.push(d);c.push("</ul>")},makeUlLineClass:function(b,a){return b.view.showLine&&!a.isLastNode?e.line.LINE:""},removeChildNodes:function(b,
 a){if(a){var c=b.data.key.children,d=a[c];if(d){for(var f=0,g=d.length;f<g;f++)i.removeNodeCache(b,d[f]);i.removeSelectedNode(b);delete a[c];b.data.keep.parent?k("#"+a.tId+e.id.UL).empty():(a.isParent=!1,a.open=!1,c=k("#"+a.tId+e.id.SWITCH),d=k("#"+a.tId+e.id.ICON),h.replaceSwitchClass(a,c,e.folder.DOCU),h.replaceIcoClass(a,d,e.folder.DOCU),k("#"+a.tId+e.id.UL).remove())}}},setFirstNode:function(b,a){var c=b.data.key.children;if(a[c].length>0)a[c][0].isFirstNode=!0},setLastNode:function(b,a){var c=
 b.data.key.children,d=a[c].length;if(d>0)a[c][d-1].isLastNode=!0},removeNode:function(b,a){var c=i.getRoot(b),d=b.data.key.children,f=a.parentTId?a.getParentNode():c;a.isFirstNode=!1;a.isLastNode=!1;a.getPreNode=function(){return null};a.getNextNode=function(){return null};k("#"+a.tId).remove();i.removeNodeCache(b,a);i.removeSelectedNode(b,a);for(var g=0,l=f[d].length;g<l;g++)if(f[d][g].tId==a.tId){f[d].splice(g,1);break}h.setFirstNode(b,f);h.setLastNode(b,f);var j,g=f[d].length;if(!b.data.keep.parent&&
 g==0)f.isParent=!1,f.open=!1,g=k("#"+f.tId+e.id.UL),l=k("#"+f.tId+e.id.SWITCH),j=k("#"+f.tId+e.id.ICON),h.replaceSwitchClass(f,l,e.folder.DOCU),h.replaceIcoClass(f,j,e.folder.DOCU),g.css("display","none");else if(b.view.showLine&&g>0){var m=f[d][g-1],g=k("#"+m.tId+e.id.UL),l=k("#"+m.tId+e.id.SWITCH);j=k("#"+m.tId+e.id.ICON);f==c?f[d].length==1?h.replaceSwitchClass(m,l,e.line.ROOT):(c=k("#"+f[d][0].tId+e.id.SWITCH),h.replaceSwitchClass(f[d][0],c,e.line.ROOTS),h.replaceSwitchClass(m,l,e.line.BOTTOM)):
 h.replaceSwitchClass(m,l,e.line.BOTTOM);g.removeClass(e.line.LINE)}},replaceIcoClass:function(b,a,c){if(a&&!b.isAjaxing&&(b=a.attr("class"),b!=void 0)){b=b.split("_");switch(c){case e.folder.OPEN:case e.folder.CLOSE:case e.folder.DOCU:b[b.length-1]=c}a.attr("class",b.join("_"))}},replaceSwitchClass:function(b,a,c){if(a){var d=a.attr("class");if(d!=void 0){d=d.split("_");switch(c){case e.line.ROOT:case e.line.ROOTS:case e.line.CENTER:case e.line.BOTTOM:case e.line.NOLINE:d[0]=h.makeNodeLineClassEx(b)+
 c;break;case e.folder.OPEN:case e.folder.CLOSE:case e.folder.DOCU:d[1]=c}a.attr("class",d.join("_"));c!==e.folder.DOCU?a.removeAttr("disabled"):a.attr("disabled","disabled")}}},selectNode:function(b,a,c){c||h.cancelPreSelectedNode(b);k("#"+a.tId+e.id.A).addClass(e.node.CURSELECTED);i.addSelectedNode(b,a)},setNodeFontCss:function(b,a){var c=k("#"+a.tId+e.id.A),d=h.makeNodeFontCss(b,a);d&&c.css(d)},setNodeLineIcos:function(b,a){if(a){var c=k("#"+a.tId+e.id.SWITCH),d=k("#"+a.tId+e.id.UL),f=k("#"+a.tId+
 e.id.ICON),g=h.makeUlLineClass(b,a);g.length==0?d.removeClass(e.line.LINE):d.addClass(g);c.attr("class",h.makeNodeLineClass(b,a));a.isParent?c.removeAttr("disabled"):c.attr("disabled","disabled");f.removeAttr("style");f.attr("style",h.makeNodeIcoStyle(b,a));f.attr("class",h.makeNodeIcoClass(b,a))}},setNodeName:function(b,a){var c=b.data.key.name,d=i.getTitleKey(b),f=k("#"+a.tId+e.id.SPAN);f.empty();b.view.nameIsHTML?f.html(a[c]):f.text(a[c]);j.apply(b.view.showTitle,[b.treeId,a],b.view.showTitle)&&
 k("#"+a.tId+e.id.A).attr("title",!a[d]?"":a[d])},setNodeTarget:function(b){k("#"+b.tId+e.id.A).attr("target",h.makeNodeTarget(b))},setNodeUrl:function(b,a){var c=k("#"+a.tId+e.id.A),d=h.makeNodeUrl(b,a);d==null||d.length==0?c.removeAttr("href"):c.attr("href",d)},switchNode:function(b,a){a.open||!j.canAsync(b,a)?h.expandCollapseNode(b,a,!a.open):b.async.enable?h.asyncNode(b,a)||h.expandCollapseNode(b,a,!a.open):a&&h.expandCollapseNode(b,a,!a.open)}};k.fn.zTree={consts:{event:{NODECREATED:"ztree_nodeCreated",
 CLICK:"ztree_click",EXPAND:"ztree_expand",COLLAPSE:"ztree_collapse",ASYNC_SUCCESS:"ztree_async_success",ASYNC_ERROR:"ztree_async_error"},id:{A:"_a",ICON:"_ico",SPAN:"_span",SWITCH:"_switch",UL:"_ul"},line:{ROOT:"root",ROOTS:"roots",CENTER:"center",BOTTOM:"bottom",NOLINE:"noline",LINE:"line"},folder:{OPEN:"open",CLOSE:"close",DOCU:"docu"},node:{CURSELECTED:"curSelectedNode"}},_z:{tools:j,view:h,event:n,data:i},getZTreeObj:function(b){return(b=i.getZTreeTools(b))?b:null},init:function(b,a,c){var d=
 j.clone(I);k.extend(!0,d,a);d.treeId=b.attr("id");d.treeObj=b;d.treeObj.empty();p[d.treeId]=d;if(k.browser.msie&&parseInt(k.browser.version)<7)d.view.expandSpeed="";i.initRoot(d);b=i.getRoot(d);a=d.data.key.children;c=c?j.clone(j.isArray(c)?c:[c]):[];b[a]=d.data.simpleData.enable?i.transformTozTreeFormat(d,c):c;i.initCache(d);n.bindTree(d);n.bindEvent(d);c={setting:d,addNodes:function(a,b,c){function e(){h.addNodes(d,a,i,c==!0)}if(!b)return null;a||(a=null);if(a&&!a.isParent&&d.data.keep.leaf)return null;
 var i=j.clone(j.isArray(b)?b:[b]);j.canAsync(d,a)?h.asyncNode(d,a,c,e):e();return i},cancelSelectedNode:function(a){h.cancelPreSelectedNode(this.setting,a)},expandAll:function(a){a=!!a;h.expandCollapseSonNode(this.setting,null,a,!0);return a},expandNode:function(a,b,c,e,m){if(!a||!a.isParent)return null;b!==!0&&b!==!1&&(b=!a.open);if((m=!!m)&&b&&j.apply(d.callback.beforeExpand,[d.treeId,a],!0)==!1)return null;else if(m&&!b&&j.apply(d.callback.beforeCollapse,[d.treeId,a],!0)==!1)return null;b&&a.parentTId&&
 h.expandCollapseParentNode(this.setting,a.getParentNode(),b,!1);if(b===a.open&&!c)return null;i.getRoot(d).expandTriggerFlag=m;c?h.expandCollapseSonNode(this.setting,a,b,!0,function(){e!==!1&&k("#"+a.tId).focus().blur()}):(a.open=!b,h.switchNode(this.setting,a),e!==!1&&k("#"+a.tId).focus().blur());return b},getNodes:function(){return i.getNodes(this.setting)},getNodeByParam:function(a,b,c){return!a?null:i.getNodeByParam(this.setting,c?c[this.setting.data.key.children]:i.getNodes(this.setting),a,b)},
 getNodeByTId:function(a){return i.getNodeCache(this.setting,a)},getNodesByParam:function(a,b,c){return!a?null:i.getNodesByParam(this.setting,c?c[this.setting.data.key.children]:i.getNodes(this.setting),a,b)},getNodesByParamFuzzy:function(a,b,c){return!a?null:i.getNodesByParamFuzzy(this.setting,c?c[this.setting.data.key.children]:i.getNodes(this.setting),a,b)},getNodesByFilter:function(a,b,c,d){b=!!b;return!a||typeof a!="function"?b?null:[]:i.getNodesByFilter(this.setting,c?c[this.setting.data.key.children]:
 i.getNodes(this.setting),a,b,d)},getNodeIndex:function(a){if(!a)return null;for(var b=d.data.key.children,c=a.parentTId?a.getParentNode():i.getRoot(this.setting),e=0,h=c[b].length;e<h;e++)if(c[b][e]==a)return e;return-1},getSelectedNodes:function(){for(var a=[],b=i.getRoot(this.setting).curSelectedList,c=0,d=b.length;c<d;c++)a.push(b[c]);return a},isSelectedNode:function(a){return i.isSelectedNode(this.setting,a)},reAsyncChildNodes:function(a,b,c){if(this.setting.async.enable){var d=!a;d&&(a=i.getRoot(this.setting));
 b=="refresh"&&(a[this.setting.data.key.children]=[],d?this.setting.treeObj.empty():k("#"+a.tId+e.id.UL).empty());h.asyncNode(this.setting,d?null:a,!!c)}},refresh:function(){this.setting.treeObj.empty();var a=i.getRoot(this.setting),b=a[this.setting.data.key.children];i.initRoot(this.setting);a[this.setting.data.key.children]=b;i.initCache(this.setting);h.createNodes(this.setting,0,a[this.setting.data.key.children])},removeChildNodes:function(a){if(!a)return null;var b=a[d.data.key.children];h.removeChildNodes(d,
 a);return b?b:null},removeNode:function(a,b){a&&(b=!!b,b&&j.apply(d.callback.beforeRemove,[d.treeId,a],!0)==!1||(h.removeNode(d,a),b&&this.setting.treeObj.trigger(e.event.REMOVE,[d.treeId,a])))},selectNode:function(a,b){a&&j.uCanDo(this.setting)&&(b=d.view.selectedMulti&&b,a.parentTId?h.expandCollapseParentNode(this.setting,a.getParentNode(),!0,!1,function(){k("#"+a.tId).focus().blur()}):k("#"+a.tId).focus().blur(),h.selectNode(this.setting,a,b))},transformTozTreeNodes:function(a){return i.transformTozTreeFormat(this.setting,
 a)},transformToArray:function(a){return i.transformToArrayFormat(this.setting,a)},updateNode:function(a){a&&k("#"+a.tId).get(0)&&j.uCanDo(this.setting)&&(h.setNodeName(this.setting,a),h.setNodeTarget(a),h.setNodeUrl(this.setting,a),h.setNodeLineIcos(this.setting,a),h.setNodeFontCss(this.setting,a))}};b.treeTools=c;i.setZTreeTools(d,c);b[a]&&b[a].length>0?h.createNodes(d,0,b[a]):d.async.enable&&d.async.url&&d.async.url!==""&&h.asyncNode(d);return c}};var K=k.fn.zTree,e=K.consts})(jQuery);

 /!*
 * JQuery zTree excheck 3.3
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2012-07-16
 *!/
 (function(j){var p,q,r,o={event:{CHECK:"ztree_check"},id:{CHECK:"_check"},checkbox:{STYLE:"checkbox",DEFAULT:"chk",DISABLED:"disable",FALSE:"false",TRUE:"true",FULL:"full",PART:"part",FOCUS:"focus"},radio:{STYLE:"radio",TYPE_ALL:"all",TYPE_LEVEL:"level"}},u={check:{enable:!1,autoCheckTrigger:!1,chkStyle:o.checkbox.STYLE,nocheckInherit:!1,radioType:o.radio.TYPE_LEVEL,chkboxType:{Y:"ps",N:"ps"}},data:{key:{checked:"checked"}},callback:{beforeCheck:null,onCheck:null}};p=function(c,a){if(a.chkDisabled===
 !0)return!1;var b=g.getSetting(c.data.treeId),d=b.data.key.checked;if(n.apply(b.callback.beforeCheck,[b.treeId,a],!0)==!1)return!0;a[d]=!a[d];e.checkNodeRelation(b,a);d=j("#"+a.tId+i.id.CHECK);e.setChkClass(b,d,a);e.repairParentChkClassWithSelf(b,a);b.treeObj.trigger(i.event.CHECK,[b.treeId,a]);return!0};q=function(c,a){if(a.chkDisabled===!0)return!1;var b=g.getSetting(c.data.treeId),d=j("#"+a.tId+i.id.CHECK);a.check_Focus=!0;e.setChkClass(b,d,a);return!0};r=function(c,a){if(a.chkDisabled===!0)return!1;
 var b=g.getSetting(c.data.treeId),d=j("#"+a.tId+i.id.CHECK);a.check_Focus=!1;e.setChkClass(b,d,a);return!0};j.extend(!0,j.fn.zTree.consts,o);j.extend(!0,j.fn.zTree._z,{tools:{},view:{checkNodeRelation:function(c,a){var b,d,f,k=c.data.key.children,m=c.data.key.checked;b=i.radio;if(c.check.chkStyle==b.STYLE){var h=g.getRadioCheckedList(c);if(a[m])if(c.check.radioType==b.TYPE_ALL){for(d=h.length-1;d>=0;d--)b=h[d],b[m]=!1,h.splice(d,1),e.setChkClass(c,j("#"+b.tId+i.id.CHECK),b),b.parentTId!=a.parentTId&&
 e.repairParentChkClassWithSelf(c,b);h.push(a)}else{h=a.parentTId?a.getParentNode():g.getRoot(c);for(d=0,f=h[k].length;d<f;d++)b=h[k][d],b[m]&&b!=a&&(b[m]=!1,e.setChkClass(c,j("#"+b.tId+i.id.CHECK),b))}else if(c.check.radioType==b.TYPE_ALL)for(d=0,f=h.length;d<f;d++)if(a==h[d]){h.splice(d,1);break}}else a[m]&&(!a[k]||a[k].length==0||c.check.chkboxType.Y.indexOf("s")>-1)&&e.setSonNodeCheckBox(c,a,!0),!a[m]&&(!a[k]||a[k].length==0||c.check.chkboxType.N.indexOf("s")>-1)&&e.setSonNodeCheckBox(c,a,!1),
 a[m]&&c.check.chkboxType.Y.indexOf("p")>-1&&e.setParentNodeCheckBox(c,a,!0),!a[m]&&c.check.chkboxType.N.indexOf("p")>-1&&e.setParentNodeCheckBox(c,a,!1)},makeChkClass:function(c,a){var b=c.data.key.checked,d=i.checkbox,f=i.radio,k="",k=a.chkDisabled===!0?d.DISABLED:a.halfCheck?d.PART:c.check.chkStyle==f.STYLE?a.check_Child_State<1?d.FULL:d.PART:a[b]?a.check_Child_State===2||a.check_Child_State===-1?d.FULL:d.PART:a.check_Child_State<1?d.FULL:d.PART,b=c.check.chkStyle+"_"+(a[b]?d.TRUE:d.FALSE)+"_"+
 k,b=a.check_Focus&&a.chkDisabled!==!0?b+"_"+d.FOCUS:b;return"button "+d.DEFAULT+" "+b},repairAllChk:function(c,a){if(c.check.enable&&c.check.chkStyle===i.checkbox.STYLE)for(var b=c.data.key.checked,d=c.data.key.children,f=g.getRoot(c),k=0,m=f[d].length;k<m;k++){var h=f[d][k];h.nocheck!==!0&&(h[b]=a);e.setSonNodeCheckBox(c,h,a)}},repairChkClass:function(c,a){if(a){g.makeChkFlag(c,a);var b=j("#"+a.tId+i.id.CHECK);e.setChkClass(c,b,a)}},repairParentChkClass:function(c,a){if(a&&a.parentTId){var b=a.getParentNode();
 e.repairChkClass(c,b);e.repairParentChkClass(c,b)}},repairParentChkClassWithSelf:function(c,a){if(a){var b=c.data.key.children;a[b]&&a[b].length>0?e.repairParentChkClass(c,a[b][0]):e.repairParentChkClass(c,a)}},repairSonChkDisabled:function(c,a,b){if(a){var d=c.data.key.children;if(a.chkDisabled!=b)a.chkDisabled=b,a.nocheck!==!0&&e.repairChkClass(c,a);if(a[d])for(var f=0,k=a[d].length;f<k;f++)e.repairSonChkDisabled(c,a[d][f],b)}},repairParentChkDisabled:function(c,a,b){if(a){if(a.chkDisabled!=b)a.chkDisabled=
 b,a.nocheck!==!0&&e.repairChkClass(c,a);e.repairParentChkDisabled(c,a.getParentNode(),b)}},setChkClass:function(c,a,b){a&&(b.nocheck===!0?a.hide():a.show(),a.removeClass(),a.addClass(e.makeChkClass(c,b)))},setParentNodeCheckBox:function(c,a,b,d){var f=c.data.key.children,k=c.data.key.checked,m=j("#"+a.tId+i.id.CHECK);d||(d=a);g.makeChkFlag(c,a);a.nocheck!==!0&&a.chkDisabled!==!0&&(a[k]=b,e.setChkClass(c,m,a),c.check.autoCheckTrigger&&a!=d&&a.nocheck!==!0&&c.treeObj.trigger(i.event.CHECK,[c.treeId,
 a]));if(a.parentTId){m=!0;if(!b)for(var f=a.getParentNode()[f],h=0,l=f.length;h<l;h++)if(f[h].nocheck!==!0&&f[h][k]||f[h].nocheck===!0&&f[h].check_Child_State>0){m=!1;break}m&&e.setParentNodeCheckBox(c,a.getParentNode(),b,d)}},setSonNodeCheckBox:function(c,a,b,d){if(a){var f=c.data.key.children,k=c.data.key.checked,m=j("#"+a.tId+i.id.CHECK);d||(d=a);var h=!1;if(a[f])for(var l=0,n=a[f].length;l<n&&a.chkDisabled!==!0;l++){var o=a[f][l];e.setSonNodeCheckBox(c,o,b,d);o.chkDisabled===!0&&(h=!0)}if(a!=
 g.getRoot(c)&&a.chkDisabled!==!0){h&&a.nocheck!==!0&&g.makeChkFlag(c,a);if(a.nocheck!==!0){if(a[k]=b,!h)a.check_Child_State=a[f]&&a[f].length>0?b?2:0:-1}else a.check_Child_State=-1;e.setChkClass(c,m,a);c.check.autoCheckTrigger&&a!=d&&a.nocheck!==!0&&c.treeObj.trigger(i.event.CHECK,[c.treeId,a])}}}},event:{},data:{getRadioCheckedList:function(c){for(var a=g.getRoot(c).radioCheckedList,b=0,d=a.length;b<d;b++)g.getNodeCache(c,a[b].tId)||(a.splice(b,1),b--,d--);return a},getCheckStatus:function(c,a){if(!c.check.enable||
 a.nocheck)return null;var b=c.data.key.checked;return{checked:a[b],half:a.halfCheck?a.halfCheck:c.check.chkStyle==i.radio.STYLE?a.check_Child_State===2:a[b]?a.check_Child_State>-1&&a.check_Child_State<2:a.check_Child_State>0}},getTreeCheckedNodes:function(c,a,b,d){if(!a)return[];for(var f=c.data.key.children,k=c.data.key.checked,e=b&&c.check.chkStyle==i.radio.STYLE&&c.check.radioType==i.radio.TYPE_ALL,d=!d?[]:d,h=0,l=a.length;h<l;h++){if(a[h].nocheck!==!0&&a[h][k]==b&&(d.push(a[h]),e))break;g.getTreeCheckedNodes(c,
 a[h][f],b,d);if(e&&d.length>0)break}return d},getTreeChangeCheckedNodes:function(c,a,b){if(!a)return[];for(var d=c.data.key.children,f=c.data.key.checked,b=!b?[]:b,e=0,i=a.length;e<i;e++)a[e].nocheck!==!0&&a[e][f]!=a[e].checkedOld&&b.push(a[e]),g.getTreeChangeCheckedNodes(c,a[e][d],b);return b},makeChkFlag:function(c,a){if(a){var b=c.data.key.children,d=c.data.key.checked,f=-1;if(a[b])for(var e=!1,g=0,h=a[b].length;g<h;g++){var l=a[b][g],j=-1;if(c.check.chkStyle==i.radio.STYLE)if(j=l.nocheck===!0?
 l.check_Child_State:l.halfCheck===!0?2:l.nocheck!==!0&&l[d]?2:l.check_Child_State>0?2:0,j==2){f=2;break}else j==0&&(f=0);else if(c.check.chkStyle==i.checkbox.STYLE){j=l.nocheck===!0?l.check_Child_State:l.halfCheck===!0?1:l.nocheck!==!0&&l[d]?l.check_Child_State===-1||l.check_Child_State===2?2:1:l.check_Child_State>0?1:0;if(j===1){f=1;break}else if(j===2&&e&&j!==f){f=1;break}else if(f===2&&j>-1&&j<2){f=1;break}else j>-1&&(f=j);e||(e=l.nocheck!==!0)}}a.check_Child_State=f}}}});var o=j.fn.zTree,n=o._z.tools,
 i=o.consts,e=o._z.view,g=o._z.data;g.exSetting(u);g.addInitBind(function(c){var a=c.treeObj,b=i.event;a.unbind(b.CHECK);a.bind(b.CHECK,function(a,b,e){n.apply(c.callback.onCheck,[a,b,e])})});g.addInitCache(function(){});g.addInitNode(function(c,a,b,d,e,i){if(b){a=c.data.key.checked;typeof b[a]=="string"&&(b[a]=n.eqs(b[a],"true"));b[a]=!!b[a];b.checkedOld=b[a];b.nocheck=!!b.nocheck||c.check.nocheckInherit&&d&&!!d.nocheck;b.chkDisabled=!!b.chkDisabled||d&&!!d.chkDisabled;if(typeof b.halfCheck=="string")b.halfCheck=
 n.eqs(b.halfCheck,"true");b.halfCheck=!!b.halfCheck;b.check_Child_State=-1;b.check_Focus=!1;b.getCheckStatus=function(){return g.getCheckStatus(c,b)};i&&g.makeChkFlag(c,d)}});g.addInitProxy(function(c){var a=c.target,b=g.getSetting(c.data.treeId),d="",e=null,k="",j=null;if(n.eqs(c.type,"mouseover")){if(b.check.enable&&n.eqs(a.tagName,"span")&&a.getAttribute("treeNode"+i.id.CHECK)!==null)d=a.parentNode.id,k="mouseoverCheck"}else if(n.eqs(c.type,"mouseout")){if(b.check.enable&&n.eqs(a.tagName,"span")&&
 a.getAttribute("treeNode"+i.id.CHECK)!==null)d=a.parentNode.id,k="mouseoutCheck"}else if(n.eqs(c.type,"click")&&b.check.enable&&n.eqs(a.tagName,"span")&&a.getAttribute("treeNode"+i.id.CHECK)!==null)d=a.parentNode.id,k="checkNode";if(d.length>0)switch(e=g.getNodeCache(b,d),k){case "checkNode":j=p;break;case "mouseoverCheck":j=q;break;case "mouseoutCheck":j=r}return{stop:!1,node:e,nodeEventType:k,nodeEventCallback:j,treeEventType:"",treeEventCallback:null}});g.addInitRoot(function(c){g.getRoot(c).radioCheckedList=
 []});g.addBeforeA(function(c,a,b){var d=c.data.key.checked;c.check.enable&&(g.makeChkFlag(c,a),c.check.chkStyle==i.radio.STYLE&&c.check.radioType==i.radio.TYPE_ALL&&a[d]&&g.getRoot(c).radioCheckedList.push(a),b.push("<span ID='",a.tId,i.id.CHECK,"' class='",e.makeChkClass(c,a),"' treeNode",i.id.CHECK,a.nocheck===!0?" style='display:none;'":"","></span>"))});g.addZTreeTools(function(c,a){a.checkNode=function(a,b,g,m){var h=this.setting.data.key.checked;if(a.chkDisabled!==!0&&(b!==!0&&b!==!1&&(b=!a[h]),
 m=!!m,(a[h]!==b||g)&&!(m&&n.apply(this.setting.callback.beforeCheck,[this.setting.treeId,a],!0)==!1)&&n.uCanDo(this.setting)&&this.setting.check.enable&&a.nocheck!==!0))a[h]=b,b=j("#"+a.tId+i.id.CHECK),(g||this.setting.check.chkStyle===i.radio.STYLE)&&e.checkNodeRelation(this.setting,a),e.setChkClass(this.setting,b,a),e.repairParentChkClassWithSelf(this.setting,a),m&&c.treeObj.trigger(i.event.CHECK,[c.treeId,a])};a.checkAllNodes=function(a){e.repairAllChk(this.setting,!!a)};a.getCheckedNodes=function(a){var b=
 this.setting.data.key.children;return g.getTreeCheckedNodes(this.setting,g.getRoot(c)[b],a!==!1)};a.getChangeCheckedNodes=function(){var a=this.setting.data.key.children;return g.getTreeChangeCheckedNodes(this.setting,g.getRoot(c)[a])};a.setChkDisabled=function(a,b){b=!!b;e.repairSonChkDisabled(this.setting,a,b);b||e.repairParentChkDisabled(this.setting,a,b)};var b=a.updateNode;a.updateNode=function(c,f){b&&b.apply(a,arguments);if(c&&this.setting.check.enable&&j("#"+c.tId).get(0)&&n.uCanDo(this.setting)){var g=
 j("#"+c.tId+i.id.CHECK);(f==!0||this.setting.check.chkStyle===i.radio.STYLE)&&e.checkNodeRelation(this.setting,c);e.setChkClass(this.setting,g,c);e.repairParentChkClassWithSelf(this.setting,c)}}});var s=e.createNodes;e.createNodes=function(c,a,b,d){s&&s.apply(e,arguments);b&&e.repairParentChkClassWithSelf(c,d)};var t=e.removeNode;e.removeNode=function(c,a){var b=a.getParentNode();t&&t.apply(e,arguments);a&&b&&(e.repairChkClass(c,b),e.repairParentChkClass(c,b))}})(jQuery);

 /!*
 * JQuery zTree exedit 3.3
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2012-07-16
 *!/
 (function(k){var F={event:{DRAG:"ztree_drag",DROP:"ztree_drop",REMOVE:"ztree_remove",RENAME:"ztree_rename"},id:{EDIT:"_edit",INPUT:"_input",REMOVE:"_remove"},move:{TYPE_INNER:"inner",TYPE_PREV:"prev",TYPE_NEXT:"next"},node:{CURSELECTED_EDIT:"curSelectedNode_Edit",TMPTARGET_TREE:"tmpTargetzTree",TMPTARGET_NODE:"tmpTargetNode"}},D={onHoverOverNode:function(b,a){var c=p.getSetting(b.data.treeId),d=p.getRoot(c);if(d.curHoverNode!=a)D.onHoverOutNode(b);d.curHoverNode=a;f.addHoverDom(c,a)},onHoverOutNode:function(b){var b=
 p.getSetting(b.data.treeId),a=p.getRoot(b);if(a.curHoverNode&&!p.isSelectedNode(b,a.curHoverNode))f.removeTreeDom(b,a.curHoverNode),a.curHoverNode=null},onMousedownNode:function(b,a){function c(b){if(z.dragFlag==0&&Math.abs(K-b.clientX)<g.edit.drag.minMoveSize&&Math.abs(L-b.clientY)<g.edit.drag.minMoveSize)return!0;var a,c,e,j,l;l=g.data.key.children;h.noSel(g);k("body").css("cursor","pointer");if(z.dragFlag==0){if(h.apply(g.callback.beforeDrag,[g.treeId,m],!0)==!1)return q(b),!0;for(a=0,c=m.length;a<
 c;a++){if(a==0)z.dragNodeShowBefore=[];e=m[a];e.isParent&&e.open?(f.expandCollapseNode(g,e,!e.open),z.dragNodeShowBefore[e.tId]=!0):z.dragNodeShowBefore[e.tId]=!1}z.dragFlag=1;z.showHoverDom=!1;h.showIfameMask(g,!0);e=!0;j=-1;if(m.length>1){var s=m[0].parentTId?m[0].getParentNode()[l]:p.getNodes(g);l=[];for(a=0,c=s.length;a<c;a++)if(z.dragNodeShowBefore[s[a].tId]!==void 0&&(e&&j>-1&&j+1!==a&&(e=!1),l.push(s[a]),j=a),m.length===l.length){m=l;break}}e&&(D=m[0].getPreNode(),E=m[m.length-1].getNextNode());
 y=k("<ul class='zTreeDragUL'></ul>");for(a=0,c=m.length;a<c;a++)if(e=m[a],e.editNameFlag=!1,f.selectNode(g,e,a>0),f.removeTreeDom(g,e),j=k("<li id='"+e.tId+"_tmp'></li>"),j.append(k("#"+e.tId+d.id.A).clone()),j.css("padding","0"),j.children("#"+e.tId+d.id.A).removeClass(d.node.CURSELECTED),y.append(j),a==g.edit.drag.maxShowNodeNum-1){j=k("<li id='"+e.tId+"_moretmp'><a>  ...  </a></li>");y.append(j);break}y.attr("id",m[0].tId+d.id.UL+"_tmp");y.addClass(g.treeObj.attr("class"));y.appendTo("body");t=
 k("<span class='tmpzTreeMove_arrow'></span>");t.attr("id","zTreeMove_arrow_tmp");t.appendTo("body");g.treeObj.trigger(d.event.DRAG,[b,g.treeId,m])}if(z.dragFlag==1){r&&t.attr("id")==b.target.id&&u&&b.clientX+x.scrollLeft()+2>k("#"+u+d.id.A,r).offset().left?(e=k("#"+u+d.id.A,r),b.target=e.length>0?e.get(0):b.target):r&&(r.removeClass(d.node.TMPTARGET_TREE),u&&k("#"+u+d.id.A,r).removeClass(d.node.TMPTARGET_NODE+"_"+d.move.TYPE_PREV).removeClass(d.node.TMPTARGET_NODE+"_"+F.move.TYPE_NEXT).removeClass(d.node.TMPTARGET_NODE+
 "_"+F.move.TYPE_INNER));u=r=null;G=!1;i=g;e=p.getSettings();for(var B in e)if(e[B].treeId&&e[B].edit.enable&&e[B].treeId!=g.treeId&&(b.target.id==e[B].treeId||k(b.target).parents("#"+e[B].treeId).length>0))G=!0,i=e[B];B=x.scrollTop();j=x.scrollLeft();l=i.treeObj.offset();a=i.treeObj.get(0).scrollHeight;e=i.treeObj.get(0).scrollWidth;c=b.clientY+B-l.top;var o=i.treeObj.height()+l.top-b.clientY-B,n=b.clientX+j-l.left,H=i.treeObj.width()+l.left-b.clientX-j;l=c<g.edit.drag.borderMax&&c>g.edit.drag.borderMin;
 var s=o<g.edit.drag.borderMax&&o>g.edit.drag.borderMin,I=n<g.edit.drag.borderMax&&n>g.edit.drag.borderMin,C=H<g.edit.drag.borderMax&&H>g.edit.drag.borderMin,o=c>g.edit.drag.borderMin&&o>g.edit.drag.borderMin&&n>g.edit.drag.borderMin&&H>g.edit.drag.borderMin,n=l&&i.treeObj.scrollTop()<=0,H=s&&i.treeObj.scrollTop()+i.treeObj.height()+10>=a,M=I&&i.treeObj.scrollLeft()<=0,N=C&&i.treeObj.scrollLeft()+i.treeObj.width()+10>=e;if(b.target.id&&i.treeObj.find("#"+b.target.id).length>0){for(var A=b.target;A&&
 A.tagName&&!h.eqs(A.tagName,"li")&&A.id!=i.treeId;)A=A.parentNode;var O=!0;for(a=0,c=m.length;a<c;a++)if(e=m[a],A.id===e.tId){O=!1;break}else if(k("#"+e.tId).find("#"+A.id).length>0){O=!1;break}if(O&&b.target.id&&(b.target.id==A.id+d.id.A||k(b.target).parents("#"+A.id+d.id.A).length>0))r=k(A),u=A.id}e=m[0];if(o&&(b.target.id==i.treeId||k(b.target).parents("#"+i.treeId).length>0)){if(!r&&(b.target.id==i.treeId||n||H||M||N)&&(G||!G&&e.parentTId))r=i.treeObj;l?i.treeObj.scrollTop(i.treeObj.scrollTop()-
 10):s&&i.treeObj.scrollTop(i.treeObj.scrollTop()+10);I?i.treeObj.scrollLeft(i.treeObj.scrollLeft()-10):C&&i.treeObj.scrollLeft(i.treeObj.scrollLeft()+10);r&&r!=i.treeObj&&r.offset().left<i.treeObj.offset().left&&i.treeObj.scrollLeft(i.treeObj.scrollLeft()+r.offset().left-i.treeObj.offset().left)}y.css({top:b.clientY+B+3+"px",left:b.clientX+j+3+"px"});l=a=0;if(r&&r.attr("id")!=i.treeId){var w=u==null?null:p.getNodeCache(i,u);c=b.ctrlKey&&g.edit.drag.isMove&&g.edit.drag.isCopy||!g.edit.drag.isMove&&
 g.edit.drag.isCopy;a=!!(D&&u===D.tId);l=!!(E&&u===E.tId);j=e.parentTId&&e.parentTId==u;e=(c||!l)&&h.apply(i.edit.drag.prev,[i.treeId,m,w],!!i.edit.drag.prev);a=(c||!a)&&h.apply(i.edit.drag.next,[i.treeId,m,w],!!i.edit.drag.next);C=(c||!j)&&!(i.data.keep.leaf&&!w.isParent)&&h.apply(i.edit.drag.inner,[i.treeId,m,w],!!i.edit.drag.inner);if(!e&&!a&&!C){if(r=null,u="",v=d.move.TYPE_INNER,t.css({display:"none"}),window.zTreeMoveTimer)clearTimeout(window.zTreeMoveTimer),window.zTreeMoveTargetNodeTId=null}else{c=
 k("#"+u+d.id.A,r);l=w.isLastNode?null:k("#"+w.getNextNode().tId+d.id.A,r.next());s=c.offset().top;j=c.offset().left;I=e?C?0.25:a?0.5:1:-1;C=a?C?0.75:e?0.5:0:-1;b=(b.clientY+B-s)/c.height();(I==1||b<=I&&b>=-0.2)&&e?(a=1-t.width(),l=s-t.height()/2,v=d.move.TYPE_PREV):(C==0||b>=C&&b<=1.2)&&a?(a=1-t.width(),l=l==null||w.isParent&&w.open?s+c.height()-t.height()/2:l.offset().top-t.height()/2,v=d.move.TYPE_NEXT):(a=5-t.width(),l=s,v=d.move.TYPE_INNER);t.css({display:"block",top:l+"px",left:j+a+"px"});c.addClass(d.node.TMPTARGET_NODE+
 "_"+v);if(P!=u||Q!=v)J=(new Date).getTime();if(w&&w.isParent&&v==d.move.TYPE_INNER&&(b=!0,window.zTreeMoveTimer&&window.zTreeMoveTargetNodeTId!==w.tId?(clearTimeout(window.zTreeMoveTimer),window.zTreeMoveTargetNodeTId=null):window.zTreeMoveTimer&&window.zTreeMoveTargetNodeTId===w.tId&&(b=!1),b))window.zTreeMoveTimer=setTimeout(function(){v==d.move.TYPE_INNER&&w&&w.isParent&&!w.open&&(new Date).getTime()-J>i.edit.drag.autoOpenTime&&h.apply(i.callback.beforeDragOpen,[i.treeId,w],!0)&&(f.switchNode(i,
 w),i.edit.drag.autoExpandTrigger&&i.treeObj.trigger(d.event.EXPAND,[i.treeId,w]))},i.edit.drag.autoOpenTime+50),window.zTreeMoveTargetNodeTId=w.tId}}else if(v=d.move.TYPE_INNER,r&&h.apply(i.edit.drag.inner,[i.treeId,m,null],!!i.edit.drag.inner)?r.addClass(d.node.TMPTARGET_TREE):r=null,t.css({display:"none"}),window.zTreeMoveTimer)clearTimeout(window.zTreeMoveTimer),window.zTreeMoveTargetNodeTId=null;P=u;Q=v}return!1}function q(b){if(window.zTreeMoveTimer)clearTimeout(window.zTreeMoveTimer),window.zTreeMoveTargetNodeTId=
 null;Q=P=null;x.unbind("mousemove",c);x.unbind("mouseup",q);x.unbind("selectstart",e);k("body").css("cursor","auto");r&&(r.removeClass(d.node.TMPTARGET_TREE),u&&k("#"+u+d.id.A,r).removeClass(d.node.TMPTARGET_NODE+"_"+d.move.TYPE_PREV).removeClass(d.node.TMPTARGET_NODE+"_"+F.move.TYPE_NEXT).removeClass(d.node.TMPTARGET_NODE+"_"+F.move.TYPE_INNER));h.showIfameMask(g,!1);z.showHoverDom=!0;if(z.dragFlag!=0){z.dragFlag=0;var a,l,j;for(a=0,l=m.length;a<l;a++)j=m[a],j.isParent&&z.dragNodeShowBefore[j.tId]&&
 !j.open&&(f.expandCollapseNode(g,j,!j.open),delete z.dragNodeShowBefore[j.tId]);y&&y.remove();t&&t.remove();var o=b.ctrlKey&&g.edit.drag.isMove&&g.edit.drag.isCopy||!g.edit.drag.isMove&&g.edit.drag.isCopy;!o&&r&&u&&m[0].parentTId&&u==m[0].parentTId&&v==d.move.TYPE_INNER&&(r=null);if(r){var n=u==null?null:p.getNodeCache(i,u);if(h.apply(g.callback.beforeDrop,[i.treeId,m,n,v,o],!0)!=!1){var s=o?h.clone(m):m;a=function(){if(G){if(!o)for(var b=0,a=m.length;b<a;b++)f.removeNode(g,m[b]);if(v==d.move.TYPE_INNER)f.addNodes(i,
 n,s);else if(f.addNodes(i,n.getParentNode(),s),v==d.move.TYPE_PREV)for(b=0,a=s.length;b<a;b++)f.moveNode(i,n,s[b],v,!1);else for(b=-1,a=s.length-1;b<a;a--)f.moveNode(i,n,s[a],v,!1)}else if(o&&v==d.move.TYPE_INNER)f.addNodes(i,n,s);else if(o&&f.addNodes(i,n.getParentNode(),s),v==d.move.TYPE_PREV)for(b=0,a=s.length;b<a;b++)f.moveNode(i,n,s[b],v,!1);else for(b=-1,a=s.length-1;b<a;a--)f.moveNode(i,n,s[a],v,!1);for(b=0,a=s.length;b<a;b++)f.selectNode(i,s[b],b>0);k("#"+s[0].tId).focus().blur()};v==d.move.TYPE_INNER&&
 h.canAsync(i,n)?f.asyncNode(i,n,!1,a):a();g.treeObj.trigger(d.event.DROP,[b,i.treeId,s,n,v,o])}}else{for(a=0,l=m.length;a<l;a++)f.selectNode(i,m[a],a>0);g.treeObj.trigger(d.event.DROP,[b,g.treeId,m,null,null,null])}}}function e(){return!1}var l,j,g=p.getSetting(b.data.treeId),z=p.getRoot(g);if(b.button==2||!g.edit.enable||!g.edit.drag.isCopy&&!g.edit.drag.isMove)return!0;var o=b.target,n=p.getRoot(g).curSelectedList,m=[];if(p.isSelectedNode(g,a))for(l=0,j=n.length;l<j;l++){if(n[l].editNameFlag&&h.eqs(o.tagName,
 "input")&&o.getAttribute("treeNode"+d.id.INPUT)!==null)return!0;m.push(n[l]);if(m[0].parentTId!==n[l].parentTId){m=[a];break}}else m=[a];f.editNodeBlur=!0;f.cancelCurEditNode(g,null,!0);var x=k(document),y,t,r,G=!1,i=g,D,E,P=null,Q=null,u=null,v=d.move.TYPE_INNER,K=b.clientX,L=b.clientY,J=(new Date).getTime();h.uCanDo(g)&&x.bind("mousemove",c);x.bind("mouseup",q);x.bind("selectstart",e);b.preventDefault&&b.preventDefault();return!0}};k.extend(!0,k.fn.zTree.consts,F);k.extend(!0,k.fn.zTree._z,{tools:{getAbs:function(b){b=
 b.getBoundingClientRect();return[b.left,b.top]},inputFocus:function(b){b.get(0)&&(b.focus(),h.setCursorPosition(b.get(0),b.val().length))},inputSelect:function(b){b.get(0)&&(b.focus(),b.select())},setCursorPosition:function(b,a){if(b.setSelectionRange)b.focus(),b.setSelectionRange(a,a);else if(b.createTextRange){var c=b.createTextRange();c.collapse(!0);c.moveEnd("character",a);c.moveStart("character",a);c.select()}},showIfameMask:function(b,a){for(var c=p.getRoot(b);c.dragMaskList.length>0;)c.dragMaskList[0].remove(),
 c.dragMaskList.shift();if(a)for(var d=k("iframe"),e=0,f=d.length;e<f;e++){var j=d.get(e),g=h.getAbs(j),j=k("<div id='zTreeMask_"+e+"' class='zTreeMask' style='top:"+g[1]+"px; left:"+g[0]+"px; width:"+j.offsetWidth+"px; height:"+j.offsetHeight+"px;'></div>");j.appendTo("body");c.dragMaskList.push(j)}}},view:{addEditBtn:function(b,a){if(!(a.editNameFlag||k("#"+a.tId+d.id.EDIT).length>0)&&h.apply(b.edit.showRenameBtn,[b.treeId,a],b.edit.showRenameBtn)){var c=k("#"+a.tId+d.id.A),q="<span class='button edit' id='"+
 a.tId+d.id.EDIT+"' title='"+h.apply(b.edit.renameTitle,[b.treeId,a],b.edit.renameTitle)+"' treeNode"+d.id.EDIT+" style='display:none;'></span>";c.append(q);k("#"+a.tId+d.id.EDIT).bind("click",function(){if(!h.uCanDo(b)||h.apply(b.callback.beforeEditName,[b.treeId,a],!0)==!1)return!1;f.editNode(b,a);return!1}).show()}},addRemoveBtn:function(b,a){if(!(a.editNameFlag||k("#"+a.tId+d.id.REMOVE).length>0)&&h.apply(b.edit.showRemoveBtn,[b.treeId,a],b.edit.showRemoveBtn)){var c=k("#"+a.tId+d.id.A),q="<span class='button remove' id='"+
 a.tId+d.id.REMOVE+"' title='"+h.apply(b.edit.removeTitle,[b.treeId,a],b.edit.removeTitle)+"' treeNode"+d.id.REMOVE+" style='display:none;'></span>";c.append(q);k("#"+a.tId+d.id.REMOVE).bind("click",function(){if(!h.uCanDo(b)||h.apply(b.callback.beforeRemove,[b.treeId,a],!0)==!1)return!1;f.removeNode(b,a);b.treeObj.trigger(d.event.REMOVE,[b.treeId,a]);return!1}).bind("mousedown",function(){return!0}).show()}},addHoverDom:function(b,a){if(p.getRoot(b).showHoverDom)a.isHover=!0,b.edit.enable&&(f.addEditBtn(b,
 a),f.addRemoveBtn(b,a)),h.apply(b.view.addHoverDom,[b.treeId,a])},cancelCurEditNode:function(b,a){var c=p.getRoot(b),q=b.data.key.name,e=c.curEditNode;if(e){var l=c.curEditInput,j=a?a:l.val();if(!a&&h.apply(b.callback.beforeRename,[b.treeId,e,j],!0)===!1)return e.editNameFlag=!0,!1;else e[q]=j?j:l.val(),a||b.treeObj.trigger(d.event.RENAME,[b.treeId,e]);k("#"+e.tId+d.id.A).removeClass(d.node.CURSELECTED_EDIT);l.unbind();f.setNodeName(b,e);e.editNameFlag=!1;c.curEditNode=null;c.curEditInput=null;f.selectNode(b,
 e,!1)}return c.noSelection=!0},editNode:function(b,a){var c=p.getRoot(b);f.editNodeBlur=!1;if(p.isSelectedNode(b,a)&&c.curEditNode==a&&a.editNameFlag)setTimeout(function(){h.inputFocus(c.curEditInput)},0);else{var q=b.data.key.name;a.editNameFlag=!0;f.removeTreeDom(b,a);f.cancelCurEditNode(b);f.selectNode(b,a,!1);k("#"+a.tId+d.id.SPAN).html("<input type=text class='rename' id='"+a.tId+d.id.INPUT+"' treeNode"+d.id.INPUT+" >");var e=k("#"+a.tId+d.id.INPUT);e.attr("value",a[q]);b.edit.editNameSelectAll?
 h.inputSelect(e):h.inputFocus(e);e.bind("blur",function(){f.editNodeBlur||f.cancelCurEditNode(b)}).bind("keydown",function(c){c.keyCode=="13"?(f.editNodeBlur=!0,f.cancelCurEditNode(b,null,!0)):c.keyCode=="27"&&f.cancelCurEditNode(b,a[q])}).bind("click",function(){return!1}).bind("dblclick",function(){return!1});k("#"+a.tId+d.id.A).addClass(d.node.CURSELECTED_EDIT);c.curEditInput=e;c.noSelection=!1;c.curEditNode=a}},moveNode:function(b,a,c,q,e,l){var j=p.getRoot(b),g=b.data.key.children;if(a!=c&&(!b.data.keep.leaf||
 !a||a.isParent||q!=d.move.TYPE_INNER)){var h=c.parentTId?c.getParentNode():j,o=a===null||a==j;o&&a===null&&(a=j);if(o)q=d.move.TYPE_INNER;j=a.parentTId?a.getParentNode():j;if(q!=d.move.TYPE_PREV&&q!=d.move.TYPE_NEXT)q=d.move.TYPE_INNER;if(q==d.move.TYPE_INNER)if(o)c.parentTId=null;else{if(!a.isParent)a.isParent=!0,a.open=!!a.open,f.setNodeLineIcos(b,a);c.parentTId=a.tId}var n;o?n=o=b.treeObj:(!l&&q==d.move.TYPE_INNER?f.expandCollapseNode(b,a,!0,!1):l||f.expandCollapseNode(b,a.getParentNode(),!0,!1),
 o=k("#"+a.tId),n=k("#"+a.tId+d.id.UL),o.get(0)&&!n.get(0)&&(n=[],f.makeUlHtml(b,a,n,""),o.append(n.join(""))),n=k("#"+a.tId+d.id.UL));var m=k("#"+c.tId);m.get(0)?o.get(0)||m.remove():m=f.appendNodes(b,c.level,[c],null,!1,!0).join("");n.get(0)&&q==d.move.TYPE_INNER?n.append(m):o.get(0)&&q==d.move.TYPE_PREV?o.before(m):o.get(0)&&q==d.move.TYPE_NEXT&&o.after(m);var x=-1,y=0,t=null,o=null,r=c.level;if(c.isFirstNode){if(x=0,h[g].length>1)t=h[g][1],t.isFirstNode=!0}else if(c.isLastNode)x=h[g].length-1,
 t=h[g][x-1],t.isLastNode=!0;else for(n=0,m=h[g].length;n<m;n++)if(h[g][n].tId==c.tId){x=n;break}x>=0&&h[g].splice(x,1);if(q!=d.move.TYPE_INNER)for(n=0,m=j[g].length;n<m;n++)j[g][n].tId==a.tId&&(y=n);if(q==d.move.TYPE_INNER){a[g]||(a[g]=[]);if(a[g].length>0)o=a[g][a[g].length-1],o.isLastNode=!1;a[g].splice(a[g].length,0,c);c.isLastNode=!0;c.isFirstNode=a[g].length==1}else a.isFirstNode&&q==d.move.TYPE_PREV?(j[g].splice(y,0,c),o=a,o.isFirstNode=!1,c.parentTId=a.parentTId,c.isFirstNode=!0,c.isLastNode=
 !1):a.isLastNode&&q==d.move.TYPE_NEXT?(j[g].splice(y+1,0,c),o=a,o.isLastNode=!1,c.parentTId=a.parentTId,c.isFirstNode=!1,c.isLastNode=!0):(q==d.move.TYPE_PREV?j[g].splice(y,0,c):j[g].splice(y+1,0,c),c.parentTId=a.parentTId,c.isFirstNode=!1,c.isLastNode=!1);p.fixPIdKeyValue(b,c);p.setSonNodeLevel(b,c.getParentNode(),c);f.setNodeLineIcos(b,c);f.repairNodeLevelClass(b,c,r);!b.data.keep.parent&&h[g].length<1?(h.isParent=!1,h.open=!1,a=k("#"+h.tId+d.id.UL),q=k("#"+h.tId+d.id.SWITCH),g=k("#"+h.tId+d.id.ICON),
 f.replaceSwitchClass(h,q,d.folder.DOCU),f.replaceIcoClass(h,g,d.folder.DOCU),a.css("display","none")):t&&f.setNodeLineIcos(b,t);o&&f.setNodeLineIcos(b,o);b.check&&b.check.enable&&f.repairChkClass&&(f.repairChkClass(b,h),f.repairParentChkClassWithSelf(b,h),h!=c.parent&&f.repairParentChkClassWithSelf(b,c));l||f.expandCollapseParentNode(b,c.getParentNode(),!0,e)}},removeEditBtn:function(b){k("#"+b.tId+d.id.EDIT).unbind().remove()},removeRemoveBtn:function(b){k("#"+b.tId+d.id.REMOVE).unbind().remove()},
 removeTreeDom:function(b,a){a.isHover=!1;f.removeEditBtn(a);f.removeRemoveBtn(a);h.apply(b.view.removeHoverDom,[b.treeId,a])},repairNodeLevelClass:function(b,a,c){if(c!==a.level){var b=k("#"+a.tId),f=k("#"+a.tId+d.id.A),e=k("#"+a.tId+d.id.UL),c="level"+c,a="level"+a.level;b.removeClass(c);b.addClass(a);f.removeClass(c);f.addClass(a);e.removeClass(c);e.addClass(a)}}},event:{},data:{setSonNodeLevel:function(b,a,c){if(c){var d=b.data.key.children;c.level=a?a.level+1:0;if(c[d])for(var a=0,e=c[d].length;a<
 e;a++)c[d][a]&&p.setSonNodeLevel(b,c,c[d][a])}}}});var E=k.fn.zTree,h=E._z.tools,d=E.consts,f=E._z.view,p=E._z.data;p.exSetting({edit:{enable:!1,editNameSelectAll:!1,showRemoveBtn:!0,showRenameBtn:!0,removeTitle:"remove",renameTitle:"rename",drag:{autoExpandTrigger:!1,isCopy:!0,isMove:!0,prev:!0,next:!0,inner:!0,minMoveSize:5,borderMax:10,borderMin:-5,maxShowNodeNum:5,autoOpenTime:500}},view:{addHoverDom:null,removeHoverDom:null},callback:{beforeDrag:null,beforeDragOpen:null,beforeDrop:null,beforeEditName:null,
 beforeRename:null,onDrag:null,onDrop:null,onRename:null}});p.addInitBind(function(b){var a=b.treeObj,c=d.event;a.unbind(c.RENAME);a.bind(c.RENAME,function(a,c,d){h.apply(b.callback.onRename,[a,c,d])});a.unbind(c.REMOVE);a.bind(c.REMOVE,function(a,c,d){h.apply(b.callback.onRemove,[a,c,d])});a.unbind(c.DRAG);a.bind(c.DRAG,function(a,c,d,f){h.apply(b.callback.onDrag,[c,d,f])});a.unbind(c.DROP);a.bind(c.DROP,function(a,c,d,f,g,k,o){h.apply(b.callback.onDrop,[c,d,f,g,k,o])})});p.addInitCache(function(){});
 p.addInitNode(function(b,a,c){if(c)c.isHover=!1,c.editNameFlag=!1});p.addInitProxy(function(b){var a=b.target,c=p.getSetting(b.data.treeId),f=b.relatedTarget,e="",l=null,j="",g=null,k=null;if(h.eqs(b.type,"mouseover")){if(k=h.getMDom(c,a,[{tagName:"a",attrName:"treeNode"+d.id.A}]))e=k.parentNode.id,j="hoverOverNode"}else if(h.eqs(b.type,"mouseout"))k=h.getMDom(c,f,[{tagName:"a",attrName:"treeNode"+d.id.A}]),k||(e="remove",j="hoverOutNode");else if(h.eqs(b.type,"mousedown")&&(k=h.getMDom(c,a,[{tagName:"a",
 attrName:"treeNode"+d.id.A}])))e=k.parentNode.id,j="mousedownNode";if(e.length>0)switch(l=p.getNodeCache(c,e),j){case "mousedownNode":g=D.onMousedownNode;break;case "hoverOverNode":g=D.onHoverOverNode;break;case "hoverOutNode":g=D.onHoverOutNode}return{stop:!1,node:l,nodeEventType:j,nodeEventCallback:g,treeEventType:"",treeEventCallback:null}});p.addInitRoot(function(b){b=p.getRoot(b);b.curEditNode=null;b.curEditInput=null;b.curHoverNode=null;b.dragFlag=0;b.dragNodeShowBefore=[];b.dragMaskList=[];
 b.showHoverDom=!0});p.addZTreeTools(function(b,a){a.cancelEditName=function(a){var d=p.getRoot(b),e=b.data.key.name,h=d.curEditNode;d.curEditNode&&f.cancelCurEditNode(b,a?a:h[e])};a.copyNode=function(a,k,e,l){if(!k)return null;if(a&&!a.isParent&&b.data.keep.leaf&&e===d.move.TYPE_INNER)return null;var j=h.clone(k);if(!a)a=null,e=d.move.TYPE_INNER;e==d.move.TYPE_INNER?(k=function(){f.addNodes(b,a,[j],l)},h.canAsync(b,a)?f.asyncNode(b,a,l,k):k()):(f.addNodes(b,a.parentNode,[j],l),f.moveNode(b,a,j,e,
 !1,l));return j};a.editName=function(a){a&&a.tId&&a===p.getNodeCache(b,a.tId)&&(a.parentTId&&f.expandCollapseParentNode(b,a.getParentNode(),!0),f.editNode(b,a))};a.moveNode=function(a,q,e,l){function j(){f.moveNode(b,a,q,e,!1,l)}if(!q)return q;if(a&&!a.isParent&&b.data.keep.leaf&&e===d.move.TYPE_INNER)return null;else if(a&&(q.parentTId==a.tId&&e==d.move.TYPE_INNER||k("#"+q.tId).find("#"+a.tId).length>0))return null;else a||(a=null);h.canAsync(b,a)?f.asyncNode(b,a,l,j):j();return q};a.setEditable=
 function(a){b.edit.enable=a;return this.refresh()}});var K=f.cancelPreSelectedNode;f.cancelPreSelectedNode=function(b,a){for(var c=p.getRoot(b).curSelectedList,d=0,e=c.length;d<e;d++)if(!a||a===c[d])if(f.removeTreeDom(b,c[d]),a)break;K&&K.apply(f,arguments)};var L=f.createNodes;f.createNodes=function(b,a,c,d){L&&L.apply(f,arguments);c&&f.repairParentChkClassWithSelf&&f.repairParentChkClassWithSelf(b,d)};f.makeNodeUrl=function(b,a){return a.url&&!b.edit.enable?a.url:null};var J=f.removeNode;f.removeNode=
 function(b,a){var c=p.getRoot(b);if(c.curEditNode===a)c.curEditNode=null;J&&J.apply(f,arguments)};var M=f.selectNode;f.selectNode=function(b,a,c){var d=p.getRoot(b);if(p.isSelectedNode(b,a)&&d.curEditNode==a&&a.editNameFlag)return!1;M&&M.apply(f,arguments);f.addHoverDom(b,a);return!0};var N=h.uCanDo;h.uCanDo=function(b,a){var c=p.getRoot(b);return a&&(h.eqs(a.type,"mouseover")||h.eqs(a.type,"mouseout")||h.eqs(a.type,"mousedown")||h.eqs(a.type,"mouseup"))?!0:!c.curEditNode&&(N?N.apply(f,arguments):
 !0)}})(jQuery);

 */
(function ($) {
    var settings = {}, roots = {}, caches = {},
    //default consts of core
        _consts = {
            className: {
                BUTTON: "button",
                LEVEL: "level",
                ICO_LOADING: "ico_loading",
                SWITCH: "switch",
                NAME: 'node_name'
            },
            event: {
                NODECREATED: "ztree_nodeCreated",
                CLICK: "ztree_click",
                EXPAND: "ztree_expand",
                COLLAPSE: "ztree_collapse",
                ASYNC_SUCCESS: "ztree_async_success",
                ASYNC_ERROR: "ztree_async_error",
                REMOVE: "ztree_remove",
                SELECTED: "ztree_selected",
                UNSELECTED: "ztree_unselected"
            },
            id: {
                A: "_a",
                ICON: "_ico",
                SPAN: "_span",
                SWITCH: "_switch",
                UL: "_ul"
            },
            line: {
                ROOT: "root",
                ROOTS: "roots",
                CENTER: "center",
                BOTTOM: "bottom",
                NOLINE: "noline",
                LINE: "line"
            },
            folder: {
                OPEN: "open",
                CLOSE: "close",
                DOCU: "docu"
            },
            node: {
                CURSELECTED: "curSelectedNode"
            }
        },
    //default setting of core
        _setting = {
            treeId: "",
            treeObj: null,
            view: {
                addDiyDom: null,
                autoCancelSelected: true,
                dblClickExpand: true,
                expandSpeed: "fast",
                fontCss: {},
                nameIsHTML: false,
                selectedMulti: true,
                showIcon: true,
                showLine: true,
                showTitle: true,
                txtSelectedEnable: false
            },
            data: {
                key: {
                    children: "children",
                    name: "name",
                    title: "",
                    url: "url",
                    icon: "icon"
                },
                simpleData: {
                    enable: false,
                    idKey: "id",
                    pIdKey: "pId",
                    rootPId: null
                },
                keep: {
                    parent: false,
                    leaf: false
                }
            },
            async: {
                enable: false,
                contentType: "application/x-www-form-urlencoded",
                type: "post",
                dataType: "text",
                url: "",
                autoParam: [],
                otherParam: [],
                dataFilter: null
            },
            callback: {
                beforeAsync: null,
                beforeClick: null,
                beforeDblClick: null,
                beforeRightClick: null,
                beforeMouseDown: null,
                beforeMouseUp: null,
                beforeExpand: null,
                beforeCollapse: null,
                beforeRemove: null,

                onAsyncError: null,
                onAsyncSuccess: null,
                onNodeCreated: null,
                onClick: null,
                onDblClick: null,
                onRightClick: null,
                onMouseDown: null,
                onMouseUp: null,
                onExpand: null,
                onCollapse: null,
                onRemove: null
            }
        },
    //default root of core
    //zTree use root to save full data
        _initRoot = function (setting) {
            var r = data.getRoot(setting);
            if (!r) {
                r = {};
                data.setRoot(setting, r);
            }
            r[setting.data.key.children] = [];
            r.expandTriggerFlag = false;
            r.curSelectedList = [];
            r.noSelection = true;
            r.createdNodes = [];
            r.zId = 0;
            r._ver = (new Date()).getTime();
        },
    //default cache of core
        _initCache = function (setting) {
            var c = data.getCache(setting);
            if (!c) {
                c = {};
                data.setCache(setting, c);
            }
            c.nodes = [];
            c.doms = [];
        },
    //default bindEvent of core
        _bindEvent = function (setting) {
            var o = setting.treeObj,
                c = consts.event;
            o.bind(c.NODECREATED, function (event, treeId, node) {
                tools.apply(setting.callback.onNodeCreated, [event, treeId, node]);
            });

            o.bind(c.CLICK, function (event, srcEvent, treeId, node, clickFlag) {
                tools.apply(setting.callback.onClick, [srcEvent, treeId, node, clickFlag]);
            });

            o.bind(c.EXPAND, function (event, treeId, node) {
                tools.apply(setting.callback.onExpand, [event, treeId, node]);
            });

            o.bind(c.COLLAPSE, function (event, treeId, node) {
                tools.apply(setting.callback.onCollapse, [event, treeId, node]);
            });

            o.bind(c.ASYNC_SUCCESS, function (event, treeId, node, msg) {
                tools.apply(setting.callback.onAsyncSuccess, [event, treeId, node, msg]);
            });

            o.bind(c.ASYNC_ERROR, function (event, treeId, node, XMLHttpRequest, textStatus, errorThrown) {
                tools.apply(setting.callback.onAsyncError, [event, treeId, node, XMLHttpRequest, textStatus, errorThrown]);
            });

            o.bind(c.REMOVE, function (event, treeId, treeNode) {
                tools.apply(setting.callback.onRemove, [event, treeId, treeNode]);
            });

            o.bind(c.SELECTED, function (event, treeId, node) {
                tools.apply(setting.callback.onSelected, [treeId, node]);
            });
            o.bind(c.UNSELECTED, function (event, treeId, node) {
                tools.apply(setting.callback.onUnSelected, [treeId, node]);
            });
        },
        _unbindEvent = function (setting) {
            var o = setting.treeObj,
                c = consts.event;
            o.unbind(c.NODECREATED)
                .unbind(c.CLICK)
                .unbind(c.EXPAND)
                .unbind(c.COLLAPSE)
                .unbind(c.ASYNC_SUCCESS)
                .unbind(c.ASYNC_ERROR)
                .unbind(c.REMOVE)
                .unbind(c.SELECTED)
                .unbind(c.UNSELECTED);
        },
    //default event proxy of core
        _eventProxy = function (event) {
            var target = event.target,
                setting = data.getSetting(event.data.treeId),
                tId = "", node = null,
                nodeEventType = "", treeEventType = "",
                nodeEventCallback = null, treeEventCallback = null,
                tmp = null;

            if (tools.eqs(event.type, "mousedown")) {
                treeEventType = "mousedown";
            } else if (tools.eqs(event.type, "mouseup")) {
                treeEventType = "mouseup";
            } else if (tools.eqs(event.type, "contextmenu")) {
                treeEventType = "contextmenu";
            } else if (tools.eqs(event.type, "click")) {
                if (tools.eqs(target.tagName, "span") && target.getAttribute("treeNode" + consts.id.SWITCH) !== null) {
                    tId = tools.getNodeMainDom(target).id;
                    nodeEventType = "switchNode";
                } else {
                    tmp = tools.getMDom(setting, target, [{tagName: "a", attrName: "treeNode" + consts.id.A}]);
                    if (tmp) {
                        tId = tools.getNodeMainDom(tmp).id;
                        nodeEventType = "clickNode";
                    }
                }
            } else if (tools.eqs(event.type, "dblclick")) {
                treeEventType = "dblclick";
                tmp = tools.getMDom(setting, target, [{tagName: "a", attrName: "treeNode" + consts.id.A}]);
                if (tmp) {
                    tId = tools.getNodeMainDom(tmp).id;
                    nodeEventType = "switchNode";
                }
            }
            if (treeEventType.length > 0 && tId.length == 0) {
                tmp = tools.getMDom(setting, target, [{tagName: "a", attrName: "treeNode" + consts.id.A}]);
                if (tmp) {
                    tId = tools.getNodeMainDom(tmp).id;
                }
            }
            // event to node
            if (tId.length > 0) {
                node = data.getNodeCache(setting, tId);
                switch (nodeEventType) {
                    case "switchNode" :
                        if (!node.isParent) {
                            nodeEventType = "";
                        } else if (tools.eqs(event.type, "click")
                            || (tools.eqs(event.type, "dblclick") && tools.apply(setting.view.dblClickExpand, [setting.treeId, node], setting.view.dblClickExpand))) {
                            nodeEventCallback = handler.onSwitchNode;
                        } else {
                            nodeEventType = "";
                        }
                        break;
                    case "clickNode" :
                        nodeEventCallback = handler.onClickNode;
                        break;
                }
            }
            // event to zTree
            switch (treeEventType) {
                case "mousedown" :
                    treeEventCallback = handler.onZTreeMousedown;
                    break;
                case "mouseup" :
                    treeEventCallback = handler.onZTreeMouseup;
                    break;
                case "dblclick" :
                    treeEventCallback = handler.onZTreeDblclick;
                    break;
                case "contextmenu" :
                    treeEventCallback = handler.onZTreeContextmenu;
                    break;
            }
            var proxyResult = {
                stop: false,
                node: node,
                nodeEventType: nodeEventType,
                nodeEventCallback: nodeEventCallback,
                treeEventType: treeEventType,
                treeEventCallback: treeEventCallback
            };
            return proxyResult
        },
    //default init node of core
        _initNode = function (setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
            if (!n) return;
            var r = data.getRoot(setting),
                childKey = setting.data.key.children;
            n.level = level;
            n.tId = setting.treeId + "_" + (++r.zId);
            n.parentTId = parentNode ? parentNode.tId : null;
            n.open = (typeof n.open == "string") ? tools.eqs(n.open, "true") : !!n.open;
            if (n[childKey] && n[childKey].length > 0) {
                n.isParent = true;
                n.zAsync = true;
            } else {
                n.isParent = (typeof n.isParent == "string") ? tools.eqs(n.isParent, "true") : !!n.isParent;
                n.open = (n.isParent && !setting.async.enable) ? n.open : false;
                n.zAsync = !n.isParent;
            }
            n.isFirstNode = isFirstNode;
            n.isLastNode = isLastNode;
            n.getParentNode = function () {
                return data.getNodeCache(setting, n.parentTId);
            };
            n.getPreNode = function () {
                return data.getPreNode(setting, n);
            };
            n.getNextNode = function () {
                return data.getNextNode(setting, n);
            };
            n.getIndex = function () {
                return data.getNodeIndex(setting, n);
            };
            n.getPath = function () {
                return data.getNodePath(setting, n);
            };
            n.isAjaxing = false;
            data.fixPIdKeyValue(setting, n);
        },
        _init = {
            bind: [_bindEvent],
            unbind: [_unbindEvent],
            caches: [_initCache],
            nodes: [_initNode],
            proxys: [_eventProxy],
            roots: [_initRoot],
            beforeA: [],
            afterA: [],
            innerBeforeA: [],
            innerAfterA: [],
            zTreeTools: []
        },
    //method of operate data
        data = {
            addNodeCache: function (setting, node) {
                data.getCache(setting).nodes[data.getNodeCacheId(node.tId)] = node;
            },
            getNodeCacheId: function (tId) {
                return tId.substring(tId.lastIndexOf("_") + 1);
            },
            addAfterA: function (afterA) {
                _init.afterA.push(afterA);
            },
            addBeforeA: function (beforeA) {
                _init.beforeA.push(beforeA);
            },
            addInnerAfterA: function (innerAfterA) {
                _init.innerAfterA.push(innerAfterA);
            },
            addInnerBeforeA: function (innerBeforeA) {
                _init.innerBeforeA.push(innerBeforeA);
            },
            addInitBind: function (bindEvent) {
                _init.bind.push(bindEvent);
            },
            addInitUnBind: function (unbindEvent) {
                _init.unbind.push(unbindEvent);
            },
            addInitCache: function (initCache) {
                _init.caches.push(initCache);
            },
            addInitNode: function (initNode) {
                _init.nodes.push(initNode);
            },
            addInitProxy: function (initProxy, isFirst) {
                if (!!isFirst) {
                    _init.proxys.splice(0, 0, initProxy);
                } else {
                    _init.proxys.push(initProxy);
                }
            },
            addInitRoot: function (initRoot) {
                _init.roots.push(initRoot);
            },
            addNodesData: function (setting, parentNode, index, nodes) {
                var childKey = setting.data.key.children, params;
                if (!parentNode[childKey]) {
                    parentNode[childKey] = [];
                    index = -1;
                } else if (index >= parentNode[childKey].length) {
                    index = -1;
                }

                if (parentNode[childKey].length > 0 && index === 0) {
                    parentNode[childKey][0].isFirstNode = false;
                    view.setNodeLineIcos(setting, parentNode[childKey][0]);
                } else if (parentNode[childKey].length > 0 && index < 0) {
                    parentNode[childKey][parentNode[childKey].length - 1].isLastNode = false;
                    view.setNodeLineIcos(setting, parentNode[childKey][parentNode[childKey].length - 1]);
                }
                parentNode.isParent = true;

                if (index < 0) {
                    parentNode[childKey] = parentNode[childKey].concat(nodes);
                } else {
                    params = [index, 0].concat(nodes);
                    parentNode[childKey].splice.apply(parentNode[childKey], params);
                }
            },
            addSelectedNode: function (setting, node) {
                var root = data.getRoot(setting);
                if (!data.isSelectedNode(setting, node)) {
                    root.curSelectedList.push(node);
                }
            },
            addCreatedNode: function (setting, node) {
                if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {
                    var root = data.getRoot(setting);
                    root.createdNodes.push(node);
                }
            },
            addZTreeTools: function (zTreeTools) {
                _init.zTreeTools.push(zTreeTools);
            },
            exSetting: function (s) {
                $.extend(true, _setting, s);
            },
            fixPIdKeyValue: function (setting, node) {
                if (setting.data.simpleData.enable) {
                    node[setting.data.simpleData.pIdKey] = node.parentTId ? node.getParentNode()[setting.data.simpleData.idKey] : setting.data.simpleData.rootPId;
                }
            },
            getAfterA: function (setting, node, array) {
                for (var i = 0, j = _init.afterA.length; i < j; i++) {
                    _init.afterA[i].apply(this, arguments);
                }
            },
            getBeforeA: function (setting, node, array) {
                for (var i = 0, j = _init.beforeA.length; i < j; i++) {
                    _init.beforeA[i].apply(this, arguments);
                }
            },
            getInnerAfterA: function (setting, node, array) {
                for (var i = 0, j = _init.innerAfterA.length; i < j; i++) {
                    _init.innerAfterA[i].apply(this, arguments);
                }
            },
            getInnerBeforeA: function (setting, node, array) {
                for (var i = 0, j = _init.innerBeforeA.length; i < j; i++) {
                    _init.innerBeforeA[i].apply(this, arguments);
                }
            },
            getCache: function (setting) {
                return caches[setting.treeId];
            },
            getNodeIndex: function (setting, node) {
                if (!node) return null;
                var childKey = setting.data.key.children,
                    p = node.parentTId ? node.getParentNode() : data.getRoot(setting);
                for (var i = 0, l = p[childKey].length - 1; i <= l; i++) {
                    if (p[childKey][i] === node) {
                        return i;
                    }
                }
                return -1;
            },
            getNextNode: function (setting, node) {
                if (!node) return null;
                var childKey = setting.data.key.children,
                    p = node.parentTId ? node.getParentNode() : data.getRoot(setting);
                for (var i = 0, l = p[childKey].length - 1; i <= l; i++) {
                    if (p[childKey][i] === node) {
                        return (i == l ? null : p[childKey][i + 1]);
                    }
                }
                return null;
            },
            getNodeByParam: function (setting, nodes, key, value) {
                if (!nodes || !key) return null;
                var childKey = setting.data.key.children;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i][key] == value) {
                        return nodes[i];
                    }
                    var tmp = data.getNodeByParam(setting, nodes[i][childKey], key, value);
                    if (tmp) return tmp;
                }
                return null;
            },
            getNodeCache: function (setting, tId) {
                if (!tId) return null;
                var n = caches[setting.treeId].nodes[data.getNodeCacheId(tId)];
                return n ? n : null;
            },
            getNodeName: function (setting, node) {
                var nameKey = setting.data.key.name;
                return "" + node[nameKey];
            },
            getNodePath: function (setting, node) {
                if (!node) return null;

                var path;
                if (node.parentTId) {
                    path = node.getParentNode().getPath();
                } else {
                    path = [];
                }

                if (path) {
                    path.push(node);
                }

                return path;
            },
            getNodeTitle: function (setting, node) {
                var t = setting.data.key.title === "" ? setting.data.key.name : setting.data.key.title;
                return "" + node[t];
            },
            getNodes: function (setting) {
                return data.getRoot(setting)[setting.data.key.children];
            },
            getNodesByParam: function (setting, nodes, key, value) {
                if (!nodes || !key) return [];
                var childKey = setting.data.key.children,
                    result = [];
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i][key] == value) {
                        result.push(nodes[i]);
                    }
                    result = result.concat(data.getNodesByParam(setting, nodes[i][childKey], key, value));
                }
                return result;
            },
            getNodesByParamFuzzy: function (setting, nodes, key, value) {
                if (!nodes || !key) return [];
                var childKey = setting.data.key.children,
                    result = [];
                value = value.toLowerCase();
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (typeof nodes[i][key] == "string" && nodes[i][key].toLowerCase().indexOf(value) > -1) {
                        result.push(nodes[i]);
                    }
                    result = result.concat(data.getNodesByParamFuzzy(setting, nodes[i][childKey], key, value));
                }
                return result;
            },
            getNodesByFilter: function (setting, nodes, filter, isSingle, invokeParam) {
                if (!nodes) return (isSingle ? null : []);
                var childKey = setting.data.key.children,
                    result = isSingle ? null : [];
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (tools.apply(filter, [nodes[i], invokeParam], false)) {
                        if (isSingle) {
                            return nodes[i];
                        }
                        result.push(nodes[i]);
                    }
                    var tmpResult = data.getNodesByFilter(setting, nodes[i][childKey], filter, isSingle, invokeParam);
                    if (isSingle && !!tmpResult) {
                        return tmpResult;
                    }
                    result = isSingle ? tmpResult : result.concat(tmpResult);
                }
                return result;
            },
            getPreNode: function (setting, node) {
                if (!node) return null;
                var childKey = setting.data.key.children,
                    p = node.parentTId ? node.getParentNode() : data.getRoot(setting);
                for (var i = 0, l = p[childKey].length; i < l; i++) {
                    if (p[childKey][i] === node) {
                        return (i == 0 ? null : p[childKey][i - 1]);
                    }
                }
                return null;
            },
            getRoot: function (setting) {
                return setting ? roots[setting.treeId] : null;
            },
            getRoots: function () {
                return roots;
            },
            getSetting: function (treeId) {
                return settings[treeId];
            },
            getSettings: function () {
                return settings;
            },
            getZTreeTools: function (treeId) {
                var r = this.getRoot(this.getSetting(treeId));
                return r ? r.treeTools : null;
            },
            initCache: function (setting) {
                for (var i = 0, j = _init.caches.length; i < j; i++) {
                    _init.caches[i].apply(this, arguments);
                }
            },
            initNode: function (setting, level, node, parentNode, preNode, nextNode) {
                for (var i = 0, j = _init.nodes.length; i < j; i++) {
                    _init.nodes[i].apply(this, arguments);
                }
            },
            initRoot: function (setting) {
                for (var i = 0, j = _init.roots.length; i < j; i++) {
                    _init.roots[i].apply(this, arguments);
                }
            },
            isSelectedNode: function (setting, node) {
                var root = data.getRoot(setting);
                for (var i = 0, j = root.curSelectedList.length; i < j; i++) {
                    if (node === root.curSelectedList[i]) return true;
                }
                return false;
            },
            removeNodeCache: function (setting, node) {
                var childKey = setting.data.key.children;
                if (node[childKey]) {
                    for (var i = 0, l = node[childKey].length; i < l; i++) {
                        data.removeNodeCache(setting, node[childKey][i]);
                    }
                }
                data.getCache(setting).nodes[data.getNodeCacheId(node.tId)] = null;
            },
            removeSelectedNode: function (setting, node) {
                var root = data.getRoot(setting);
                for (var i = 0, j = root.curSelectedList.length; i < j; i++) {
                    if (node === root.curSelectedList[i] || !data.getNodeCache(setting, root.curSelectedList[i].tId)) {
                        root.curSelectedList.splice(i, 1);
                        setting.treeObj.trigger(consts.event.UNSELECTED, [setting.treeId, node]);
                        i--;
                        j--;
                    }
                }
            },
            setCache: function (setting, cache) {
                caches[setting.treeId] = cache;
            },
            setRoot: function (setting, root) {
                roots[setting.treeId] = root;
            },
            setZTreeTools: function (setting, zTreeTools) {
                for (var i = 0, j = _init.zTreeTools.length; i < j; i++) {
                    _init.zTreeTools[i].apply(this, arguments);
                }
            },
            transformToArrayFormat: function (setting, nodes) {
                if (!nodes) return [];
                var childKey = setting.data.key.children,
                    r = [];
                if (tools.isArray(nodes)) {
                    for (var i = 0, l = nodes.length; i < l; i++) {
                        r.push(nodes[i]);
                        if (nodes[i][childKey])
                            r = r.concat(data.transformToArrayFormat(setting, nodes[i][childKey]));
                    }
                } else {
                    r.push(nodes);
                    if (nodes[childKey])
                        r = r.concat(data.transformToArrayFormat(setting, nodes[childKey]));
                }
                return r;
            },
            transformTozTreeFormat: function (setting, sNodes) {
                var i, l,
                    key = setting.data.simpleData.idKey,
                    parentKey = setting.data.simpleData.pIdKey,
                    childKey = setting.data.key.children;
                if (!key || key == "" || !sNodes) return [];

                if (tools.isArray(sNodes)) {
                    var r = [];
                    var tmpMap = {};
                    for (i = 0, l = sNodes.length; i < l; i++) {
                        tmpMap[sNodes[i][key]] = sNodes[i];
                    }
                    for (i = 0, l = sNodes.length; i < l; i++) {
                        if (tmpMap[sNodes[i][parentKey]] && sNodes[i][key] != sNodes[i][parentKey]) {
                            if (!tmpMap[sNodes[i][parentKey]][childKey])
                                tmpMap[sNodes[i][parentKey]][childKey] = [];
                            tmpMap[sNodes[i][parentKey]][childKey].push(sNodes[i]);
                        } else {
                            r.push(sNodes[i]);
                        }
                    }
                    return r;
                } else {
                    return [sNodes];
                }
            }
        },
    //method of event proxy
        event = {
            bindEvent: function (setting) {
                for (var i = 0, j = _init.bind.length; i < j; i++) {
                    _init.bind[i].apply(this, arguments);
                }
            },
            unbindEvent: function (setting) {
                for (var i = 0, j = _init.unbind.length; i < j; i++) {
                    _init.unbind[i].apply(this, arguments);
                }
            },
            bindTree: function (setting) {
                var eventParam = {
                        treeId: setting.treeId
                    },
                    o = setting.treeObj;
                if (!setting.view.txtSelectedEnable) {
                    // for can't select text
                    o.bind('selectstart', handler.onSelectStart).css({
                        "-moz-user-select": "-moz-none"
                    });
                }
                o.bind('click', eventParam, event.proxy);
                o.bind('dblclick', eventParam, event.proxy);
                o.bind('mouseover', eventParam, event.proxy);
                o.bind('mouseout', eventParam, event.proxy);
                o.bind('mousedown', eventParam, event.proxy);
                o.bind('mouseup', eventParam, event.proxy);
                o.bind('contextmenu', eventParam, event.proxy);
            },
            unbindTree: function (setting) {
                var o = setting.treeObj;
                o.unbind('selectstart', handler.onSelectStart)
                    .unbind('click', event.proxy)
                    .unbind('dblclick', event.proxy)
                    .unbind('mouseover', event.proxy)
                    .unbind('mouseout', event.proxy)
                    .unbind('mousedown', event.proxy)
                    .unbind('mouseup', event.proxy)
                    .unbind('contextmenu', event.proxy);
            },
            doProxy: function (e) {
                var results = [];
                for (var i = 0, j = _init.proxys.length; i < j; i++) {
                    var proxyResult = _init.proxys[i].apply(this, arguments);
                    results.push(proxyResult);
                    if (proxyResult.stop) {
                        break;
                    }
                }
                return results;
            },
            proxy: function (e) {
                var setting = data.getSetting(e.data.treeId);
                if (!tools.uCanDo(setting, e)) return true;
                var results = event.doProxy(e),
                    r = true, x = false;
                for (var i = 0, l = results.length; i < l; i++) {
                    var proxyResult = results[i];
                    if (proxyResult.nodeEventCallback) {
                        x = true;
                        r = proxyResult.nodeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;
                    }
                    if (proxyResult.treeEventCallback) {
                        x = true;
                        r = proxyResult.treeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;
                    }
                }
                return r;
            }
        },
    //method of event handler
        handler = {
            onSwitchNode: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (node.open) {
                    if (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false) return true;
                    data.getRoot(setting).expandTriggerFlag = true;
                    view.switchNode(setting, node);
                } else {
                    if (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false) return true;
                    data.getRoot(setting).expandTriggerFlag = true;
                    view.switchNode(setting, node);
                }
                return true;
            },
            onClickNode: function (event, node) {
                var setting = data.getSetting(event.data.treeId),
                    clickFlag = ( (setting.view.autoCancelSelected && (event.ctrlKey || event.metaKey)) && data.isSelectedNode(setting, node)) ? 0 : (setting.view.autoCancelSelected && (event.ctrlKey || event.metaKey) && setting.view.selectedMulti) ? 2 : 1;
                if (tools.apply(setting.callback.beforeClick, [setting.treeId, node, clickFlag], true) == false) return true;
                if (clickFlag === 0) {
                    view.cancelPreSelectedNode(setting, node);
                } else {
                    view.selectNode(setting, node, clickFlag === 2);
                }
                setting.treeObj.trigger(consts.event.CLICK, [event, setting.treeId, node, clickFlag]);
                return true;
            },
            onZTreeMousedown: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (tools.apply(setting.callback.beforeMouseDown, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onMouseDown, [event, setting.treeId, node]);
                }
                return true;
            },
            onZTreeMouseup: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (tools.apply(setting.callback.beforeMouseUp, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onMouseUp, [event, setting.treeId, node]);
                }
                return true;
            },
            onZTreeDblclick: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (tools.apply(setting.callback.beforeDblClick, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onDblClick, [event, setting.treeId, node]);
                }
                return true;
            },
            onZTreeContextmenu: function (event, node) {
                var setting = data.getSetting(event.data.treeId);
                if (tools.apply(setting.callback.beforeRightClick, [setting.treeId, node], true)) {
                    tools.apply(setting.callback.onRightClick, [event, setting.treeId, node]);
                }
                return (typeof setting.callback.onRightClick) != "function";
            },
            onSelectStart: function (e) {
                var n = e.originalEvent.srcElement.nodeName.toLowerCase();
                return (n === "input" || n === "textarea" );
            }
        },
    //method of tools for zTree
        tools = {
            apply: function (fun, param, defaultValue) {
                if ((typeof fun) == "function") {
                    return fun.apply(zt, param ? param : []);
                }
                return defaultValue;
            },
            canAsync: function (setting, node) {
                var childKey = setting.data.key.children;
                return (setting.async.enable && node && node.isParent && !(node.zAsync || (node[childKey] && node[childKey].length > 0)));
            },
            clone: function (obj) {
                if (obj === null) return null;
                var o = tools.isArray(obj) ? [] : {};
                for (var i in obj) {
                    o[i] = (obj[i] instanceof Date) ? new Date(obj[i].getTime()) : (typeof obj[i] === "object" ? tools.clone(obj[i]) : obj[i]);
                }
                return o;
            },
            eqs: function (str1, str2) {
                return str1.toLowerCase() === str2.toLowerCase();
            },
            isArray: function (arr) {
                return Object.prototype.toString.apply(arr) === "[object Array]";
            },
            isElement: function (o) {
                return (
                    typeof HTMLElement === "object" ? o instanceof HTMLElement : //DOM2
                    o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string"
                );
            },
            $: function (node, exp, setting) {
                if (!!exp && typeof exp != "string") {
                    setting = exp;
                    exp = "";
                }
                if (typeof node == "string") {
                    return $(node, setting ? setting.treeObj.get(0).ownerDocument : null);
                } else {
                    return $("#" + node.tId + exp, setting ? setting.treeObj : null);
                }
            },
            getMDom: function (setting, curDom, targetExpr) {
                if (!curDom) return null;
                while (curDom && curDom.id !== setting.treeId) {
                    for (var i = 0, l = targetExpr.length; curDom.tagName && i < l; i++) {
                        if (tools.eqs(curDom.tagName, targetExpr[i].tagName) && curDom.getAttribute(targetExpr[i].attrName) !== null) {
                            return curDom;
                        }
                    }
                    curDom = curDom.parentNode;
                }
                return null;
            },
            getNodeMainDom: function (target) {
                return ($(target).parent("li").get(0) || $(target).parentsUntil("li").parent().get(0));
            },
            isChildOrSelf: function (dom, parentId) {
                return ( $(dom).closest("#" + parentId).length > 0 );
            },
            uCanDo: function (setting, e) {
                return true;
            }
        },
    //method of operate ztree dom
        view = {
            addNodes: function (setting, parentNode, index, newNodes, isSilent) {
                if (setting.data.keep.leaf && parentNode && !parentNode.isParent) {
                    return;
                }
                if (!tools.isArray(newNodes)) {
                    newNodes = [newNodes];
                }
                if (setting.data.simpleData.enable) {
                    newNodes = data.transformTozTreeFormat(setting, newNodes);
                }
                if (parentNode) {
                    var target_switchObj = $$(parentNode, consts.id.SWITCH, setting),
                        target_icoObj = $$(parentNode, consts.id.ICON, setting),
                        target_ulObj = $$(parentNode, consts.id.UL, setting);

                    if (!parentNode.open) {
                        view.replaceSwitchClass(parentNode, target_switchObj, consts.folder.CLOSE);
                        view.replaceIcoClass(parentNode, target_icoObj, consts.folder.CLOSE);
                        parentNode.open = false;
                        target_ulObj.css({
                            "display": "none"
                        });
                    }

                    data.addNodesData(setting, parentNode, index, newNodes);
                    view.createNodes(setting, parentNode.level + 1, newNodes, parentNode, index);
                    if (!isSilent) {
                        view.expandCollapseParentNode(setting, parentNode, true);
                    }
                } else {
                    data.addNodesData(setting, data.getRoot(setting), index, newNodes);
                    view.createNodes(setting, 0, newNodes, null, index);
                }
            },
            appendNodes: function (setting, level, nodes, parentNode, index, initFlag, openFlag) {
                if (!nodes) return [];
                var html = [],
                    childKey = setting.data.key.children;

                var tmpPNode = (parentNode) ? parentNode : data.getRoot(setting),
                    tmpPChild = tmpPNode[childKey],
                    isFirstNode, isLastNode;

                if (!tmpPChild || index >= tmpPChild.length - nodes.length) {
                    index = -1;
                }

                for (var i = 0, l = nodes.length; i < l; i++) {
                    var node = nodes[i];
                    if (initFlag) {
                        isFirstNode = ((index === 0 || tmpPChild.length == nodes.length) && (i == 0));
                        isLastNode = (index < 0 && i == (nodes.length - 1));
                        data.initNode(setting, level, node, parentNode, isFirstNode, isLastNode, openFlag);
                        data.addNodeCache(setting, node);
                    }

                    var childHtml = [];
                    if (node[childKey] && node[childKey].length > 0) {
                        //make child html first, because checkType
                        childHtml = view.appendNodes(setting, level + 1, node[childKey], node, -1, initFlag, openFlag && node.open);
                    }
                    if (openFlag) {

                        view.makeDOMNodeMainBefore(html, setting, node);
                        view.makeDOMNodeLine(html, setting, node);
                        data.getBeforeA(setting, node, html);
                        view.makeDOMNodeNameBefore(html, setting, node);
                        data.getInnerBeforeA(setting, node, html);
                        view.makeDOMNodeIcon(html, setting, node);
                        data.getInnerAfterA(setting, node, html);
                        view.makeDOMNodeNameAfter(html, setting, node);
                        data.getAfterA(setting, node, html);
                        if (node.isParent && node.open) {
                            view.makeUlHtml(setting, node, html, childHtml.join(''));
                        }
                        view.makeDOMNodeMainAfter(html, setting, node);
                        data.addCreatedNode(setting, node);
                    }
                }
                return html;
            },
            appendParentULDom: function (setting, node) {
                var html = [],
                    nObj = $$(node, setting);
                if (!nObj.get(0) && !!node.parentTId) {
                    view.appendParentULDom(setting, node.getParentNode());
                    nObj = $$(node, setting);
                }
                var ulObj = $$(node, consts.id.UL, setting);
                if (ulObj.get(0)) {
                    ulObj.remove();
                }
                var childKey = setting.data.key.children,
                    childHtml = view.appendNodes(setting, node.level + 1, node[childKey], node, -1, false, true);
                view.makeUlHtml(setting, node, html, childHtml.join(''));
                nObj.append(html.join(''));
            },
            asyncNode: function (setting, node, isSilent, callback) {
                var i, l;
                if (node && !node.isParent) {
                    tools.apply(callback);
                    return false;
                } else if (node && node.isAjaxing) {
                    return false;
                } else if (tools.apply(setting.callback.beforeAsync, [setting.treeId, node], true) == false) {
                    tools.apply(callback);
                    return false;
                }
                if (node) {
                    node.isAjaxing = true;
                    var icoObj = $$(node, consts.id.ICON, setting);
                    icoObj.attr({"style": "", "class": consts.className.BUTTON + " " + consts.className.ICO_LOADING});
                }

                var tmpParam = {};
                for (i = 0, l = setting.async.autoParam.length; node && i < l; i++) {
                    var pKey = setting.async.autoParam[i].split("="), spKey = pKey;
                    if (pKey.length > 1) {
                        spKey = pKey[1];
                        pKey = pKey[0];
                    }
                    tmpParam[spKey] = node[pKey];
                }
                if (tools.isArray(setting.async.otherParam)) {
                    for (i = 0, l = setting.async.otherParam.length; i < l; i += 2) {
                        tmpParam[setting.async.otherParam[i]] = setting.async.otherParam[i + 1];
                    }
                } else {
                    for (var p in setting.async.otherParam) {
                        tmpParam[p] = setting.async.otherParam[p];
                    }
                }

                var _tmpV = data.getRoot(setting)._ver;
                $.ajax({
                    contentType: setting.async.contentType,
                    cache: false,
                    type: setting.async.type,
                    url: tools.apply(setting.async.url, [setting.treeId, node], setting.async.url),
                    data: setting.async.contentType.indexOf('application/json') > -1 ? JSON.stringify(tmpParam) : tmpParam,
                    dataType: setting.async.dataType,
                    success: function (msg) {
                        if (_tmpV != data.getRoot(setting)._ver) {
                            return;
                        }
                        var newNodes = [];
                        try {
                            if (!msg || msg.length == 0) {
                                newNodes = [];
                            } else if (typeof msg == "string") {
                                newNodes = eval("(" + msg + ")");
                            } else {
                                newNodes = msg;
                            }
                        } catch (err) {
                            newNodes = msg;
                        }

                        if (node) {
                            node.isAjaxing = null;
                            node.zAsync = true;
                        }
                        view.setNodeLineIcos(setting, node);
                        if (newNodes && newNodes !== "") {
                            newNodes = tools.apply(setting.async.dataFilter, [setting.treeId, node, newNodes], newNodes);
                            view.addNodes(setting, node, -1, !!newNodes ? tools.clone(newNodes) : [], !!isSilent);
                        } else {
                            view.addNodes(setting, node, -1, [], !!isSilent);
                        }
                        setting.treeObj.trigger(consts.event.ASYNC_SUCCESS, [setting.treeId, node, msg]);
                        tools.apply(callback);
                    },
                    error: function (XMLHttpRequest, textStatus, errorThrown) {
                        if (_tmpV != data.getRoot(setting)._ver) {
                            return;
                        }
                        if (node) node.isAjaxing = null;
                        view.setNodeLineIcos(setting, node);
                        setting.treeObj.trigger(consts.event.ASYNC_ERROR, [setting.treeId, node, XMLHttpRequest, textStatus, errorThrown]);
                    }
                });
                return true;
            },
            cancelPreSelectedNode: function (setting, node, excludeNode) {
                var list = data.getRoot(setting).curSelectedList,
                    i, n;
                for (i = list.length - 1; i >= 0; i--) {
                    n = list[i];
                    if (node === n || (!node && (!excludeNode || excludeNode !== n))) {
                        $$(n, consts.id.A, setting).removeClass(consts.node.CURSELECTED);
                        if (node) {
                            data.removeSelectedNode(setting, node);
                            break;
                        } else {
                            list.splice(i, 1);
                            setting.treeObj.trigger(consts.event.UNSELECTED, [setting.treeId, n]);
                        }
                    }
                }
            },
            createNodeCallback: function (setting) {
                if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {
                    var root = data.getRoot(setting);
                    while (root.createdNodes.length > 0) {
                        var node = root.createdNodes.shift();
                        tools.apply(setting.view.addDiyDom, [setting.treeId, node]);
                        if (!!setting.callback.onNodeCreated) {
                            setting.treeObj.trigger(consts.event.NODECREATED, [setting.treeId, node]);
                        }
                    }
                }
            },
            createNodes: function (setting, level, nodes, parentNode, index) {
                if (!nodes || nodes.length == 0) return;
                var root = data.getRoot(setting),
                    childKey = setting.data.key.children,
                    openFlag = !parentNode || parentNode.open || !!$$(parentNode[childKey][0], setting).get(0);
                root.createdNodes = [];
                var zTreeHtml = view.appendNodes(setting, level, nodes, parentNode, index, true, openFlag),
                    parentObj, nextObj;

                if (!parentNode) {
                    parentObj = setting.treeObj;
                    //setting.treeObj.append(zTreeHtml.join(''));
                } else {
                    var ulObj = $$(parentNode, consts.id.UL, setting);
                    if (ulObj.get(0)) {
                        parentObj = ulObj;
                        //ulObj.append(zTreeHtml.join(''));
                    }
                }
                if (parentObj) {
                    if (index >= 0) {
                        nextObj = parentObj.children()[index];
                    }
                    if (index >= 0 && nextObj) {
                        $(nextObj).before(zTreeHtml.join(''));
                    } else {
                        parentObj.append(zTreeHtml.join(''));
                    }
                }

                view.createNodeCallback(setting);
            },
            destroy: function (setting) {
                if (!setting) return;
                data.initCache(setting);
                data.initRoot(setting);
                event.unbindTree(setting);
                event.unbindEvent(setting);
                setting.treeObj.empty();
                delete settings[setting.treeId];
            },
            expandCollapseNode: function (setting, node, expandFlag, animateFlag, callback) {
                var root = data.getRoot(setting),
                    childKey = setting.data.key.children;
                var tmpCb, _callback;
                if (!node) {
                    tools.apply(callback, []);
                    return;
                }
                if (root.expandTriggerFlag) {
                    _callback = callback;
                    tmpCb = function () {
                        if (_callback) _callback();
                        if (node.open) {
                            setting.treeObj.trigger(consts.event.EXPAND, [setting.treeId, node]);
                        } else {
                            setting.treeObj.trigger(consts.event.COLLAPSE, [setting.treeId, node]);
                        }
                    };
                    callback = tmpCb;
                    root.expandTriggerFlag = false;
                }
                if (!node.open && node.isParent && ((!$$(node, consts.id.UL, setting).get(0)) || (node[childKey] && node[childKey].length > 0 && !$$(node[childKey][0], setting).get(0)))) {
                    view.appendParentULDom(setting, node);
                    view.createNodeCallback(setting);
                }
                if (node.open == expandFlag) {
                    tools.apply(callback, []);
                    return;
                }
                var ulObj = $$(node, consts.id.UL, setting),
                    switchObj = $$(node, consts.id.SWITCH, setting),
                    icoObj = $$(node, consts.id.ICON, setting);

                if (node.isParent) {
                    node.open = !node.open;
                    if (node.iconOpen && node.iconClose) {
                        icoObj.attr("style", view.makeNodeIcoStyle(setting, node));
                    }

                    if (node.open) {
                        view.replaceSwitchClass(node, switchObj, consts.folder.OPEN);
                        view.replaceIcoClass(node, icoObj, consts.folder.OPEN);
                        if (animateFlag == false || setting.view.expandSpeed == "") {
                            ulObj.show();
                            tools.apply(callback, []);
                        } else {
                            if (node[childKey] && node[childKey].length > 0) {
                                ulObj.slideDown(setting.view.expandSpeed, callback);
                            } else {
                                ulObj.show();
                                tools.apply(callback, []);
                            }
                        }
                    } else {
                        view.replaceSwitchClass(node, switchObj, consts.folder.CLOSE);
                        view.replaceIcoClass(node, icoObj, consts.folder.CLOSE);
                        if (animateFlag == false || setting.view.expandSpeed == "" || !(node[childKey] && node[childKey].length > 0)) {
                            ulObj.hide();
                            tools.apply(callback, []);
                        } else {
                            ulObj.slideUp(setting.view.expandSpeed, callback);
                        }
                    }
                } else {
                    tools.apply(callback, []);
                }
            },
            expandCollapseParentNode: function (setting, node, expandFlag, animateFlag, callback) {
                if (!node) return;
                if (!node.parentTId) {
                    view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback);
                    return;
                } else {
                    view.expandCollapseNode(setting, node, expandFlag, animateFlag);
                }
                if (node.parentTId) {
                    view.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, animateFlag, callback);
                }
            },
            expandCollapseSonNode: function (setting, node, expandFlag, animateFlag, callback) {
                var root = data.getRoot(setting),
                    childKey = setting.data.key.children,
                    treeNodes = (node) ? node[childKey] : root[childKey],
                    selfAnimateSign = (node) ? false : animateFlag,
                    expandTriggerFlag = data.getRoot(setting).expandTriggerFlag;
                data.getRoot(setting).expandTriggerFlag = false;
                if (treeNodes) {
                    for (var i = 0, l = treeNodes.length; i < l; i++) {
                        if (treeNodes[i]) view.expandCollapseSonNode(setting, treeNodes[i], expandFlag, selfAnimateSign);
                    }
                }
                data.getRoot(setting).expandTriggerFlag = expandTriggerFlag;
                view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback);
            },
            isSelectedNode: function (setting, node) {
                if (!node) {
                    return false;
                }
                var list = data.getRoot(setting).curSelectedList,
                    i;
                for (i = list.length - 1; i >= 0; i--) {
                    if (node === list[i]) {
                        return true;
                    }
                }
                return false;
            },
            makeDOMNodeIcon: function (html, setting, node) {
                var nameStr = data.getNodeName(setting, node),
                    name = setting.view.nameIsHTML ? nameStr : nameStr.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                html.push("<span id='", node.tId, consts.id.ICON,
                    "' title='' treeNode", consts.id.ICON, " class='", view.makeNodeIcoClass(setting, node),
                    "' style='", view.makeNodeIcoStyle(setting, node), "'></span><span id='", node.tId, consts.id.SPAN,
                    "' class='", consts.className.NAME,
                    "'>", name, "</span>");
            },
            makeDOMNodeLine: function (html, setting, node) {
                html.push("<span id='", node.tId, consts.id.SWITCH, "' title='' class='", view.makeNodeLineClass(setting, node), "' treeNode", consts.id.SWITCH, "></span>");
            },
            makeDOMNodeMainAfter: function (html, setting, node) {
                html.push("</li>");
            },
            makeDOMNodeMainBefore: function (html, setting, node) {
                html.push("<li id='", node.tId, "' class='", consts.className.LEVEL, node.level, "' tabindex='0' hidefocus='true' treenode>");
            },
            makeDOMNodeNameAfter: function (html, setting, node) {
                html.push("</a>");
            },
            makeDOMNodeNameBefore: function (html, setting, node) {
                var title = data.getNodeTitle(setting, node),
                    url = view.makeNodeUrl(setting, node),
                    fontcss = view.makeNodeFontCss(setting, node),
                    fontStyle = [];
                for (var f in fontcss) {
                    fontStyle.push(f, ":", fontcss[f], ";");
                }
                html.push("<a id='", node.tId, consts.id.A, "' class='", consts.className.LEVEL, node.level, "' treeNode", consts.id.A, " onclick=\"", (node.click || ''),
                    "\" ", ((url != null && url.length > 0) ? "href='" + url + "'" : ""), " target='", view.makeNodeTarget(node), "' style='", fontStyle.join(''),
                    "'");
                if (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle) && title) {
                    html.push("title='", title.replace(/'/g, "&#39;").replace(/</g, '&lt;').replace(/>/g, '&gt;'), "'");
                }
                html.push(">");
            },
            makeNodeFontCss: function (setting, node) {
                var fontCss = tools.apply(setting.view.fontCss, [setting.treeId, node], setting.view.fontCss);
                return (fontCss && ((typeof fontCss) != "function")) ? fontCss : {};
            },
            makeNodeIcoClass: function (setting, node) {
                var icoCss = ["ico"];
                if (!node.isAjaxing) {
                    icoCss[0] = (node.iconSkin ? node.iconSkin + "_" : "") + icoCss[0];
                    if (node.isParent) {
                        icoCss.push(node.open ? consts.folder.OPEN : consts.folder.CLOSE);
                    } else {
                        icoCss.push(consts.folder.DOCU);
                    }
                }
                return consts.className.BUTTON + " " + icoCss.join('_');
            },
            makeNodeIcoStyle: function (setting, node) {
                var icoStyle = [];
                if (!node.isAjaxing) {
                    var icon = (node.isParent && node.iconOpen && node.iconClose) ? (node.open ? node.iconOpen : node.iconClose) : node[setting.data.key.icon];
                    if (icon) icoStyle.push("background:url(", icon, ") 0 0 no-repeat;");
                    if (setting.view.showIcon == false || !tools.apply(setting.view.showIcon, [setting.treeId, node], true)) {
                        icoStyle.push("width:0px;height:0px;");
                    }
                }
                return icoStyle.join('');
            },
            makeNodeLineClass: function (setting, node) {
                var lineClass = [];
                if (setting.view.showLine) {
                    if (node.level == 0 && node.isFirstNode && node.isLastNode) {
                        lineClass.push(consts.line.ROOT);
                    } else if (node.level == 0 && node.isFirstNode) {
                        lineClass.push(consts.line.ROOTS);
                    } else if (node.isLastNode) {
                        lineClass.push(consts.line.BOTTOM);
                    } else {
                        lineClass.push(consts.line.CENTER);
                    }
                } else {
                    lineClass.push(consts.line.NOLINE);
                }
                if (node.isParent) {
                    lineClass.push(node.open ? consts.folder.OPEN : consts.folder.CLOSE);
                } else {
                    lineClass.push(consts.folder.DOCU);
                }
                return view.makeNodeLineClassEx(node) + lineClass.join('_');
            },
            makeNodeLineClassEx: function (node) {
                return consts.className.BUTTON + " " + consts.className.LEVEL + node.level + " " + consts.className.SWITCH + " ";
            },
            makeNodeTarget: function (node) {
                return (node.target || "_blank");
            },
            makeNodeUrl: function (setting, node) {
                var urlKey = setting.data.key.url;
                return node[urlKey] ? node[urlKey] : null;
            },
            makeUlHtml: function (setting, node, html, content) {
                html.push("<ul id='", node.tId, consts.id.UL, "' class='", consts.className.LEVEL, node.level, " ", view.makeUlLineClass(setting, node), "' style='display:", (node.open ? "block" : "none"), "'>");
                html.push(content);
                html.push("</ul>");
            },
            makeUlLineClass: function (setting, node) {
                return ((setting.view.showLine && !node.isLastNode) ? consts.line.LINE : "");
            },
            removeChildNodes: function (setting, node) {
                if (!node) return;
                var childKey = setting.data.key.children,
                    nodes = node[childKey];
                if (!nodes) return;

                for (var i = 0, l = nodes.length; i < l; i++) {
                    data.removeNodeCache(setting, nodes[i]);
                }
                data.removeSelectedNode(setting);
                delete node[childKey];

                if (!setting.data.keep.parent) {
                    node.isParent = false;
                    node.open = false;
                    var tmp_switchObj = $$(node, consts.id.SWITCH, setting),
                        tmp_icoObj = $$(node, consts.id.ICON, setting);
                    view.replaceSwitchClass(node, tmp_switchObj, consts.folder.DOCU);
                    view.replaceIcoClass(node, tmp_icoObj, consts.folder.DOCU);
                    $$(node, consts.id.UL, setting).remove();
                } else {
                    $$(node, consts.id.UL, setting).empty();
                }
            },
            scrollIntoView: function (dom) {
                /*  debugger
                 if (!dom) {
                 return;
                 }*/
                // code src: http://jsfiddle.net/08u6cxwj/
                if (!Element.prototype.scrollIntoViewIfNeeded) {
                    Element.prototype.scrollIntoViewIfNeeded = function (centerIfNeeded) {
                        function withinBounds(value, min, max, extent) {
                            if (false === centerIfNeeded || max <= value + extent && value <= min + extent) {
                                return Math.min(max, Math.max(min, value));
                            } else {
                                return (min + max) / 2;
                            }
                        }

                        function makeArea(left, top, width, height) {
                            return {
                                "left": left, "top": top, "width": width, "height": height
                                , "right": left + width, "bottom": top + height
                                , "translate": function (x, y) {
                                    return makeArea(x + left, y + top, width, height);
                                }
                                , "relativeFromTo": function (lhs, rhs) {
                                    var newLeft = left, newTop = top;
                                    lhs = lhs.offsetParent;
                                    rhs = rhs.offsetParent;
                                    if (lhs === rhs) {
                                        return area;
                                    }
                                    for (; lhs; lhs = lhs.offsetParent) {
                                        newLeft += lhs.offsetLeft + lhs.clientLeft;
                                        newTop += lhs.offsetTop + lhs.clientTop;
                                    }
                                    for (; rhs; rhs = rhs.offsetParent) {
                                        newLeft -= rhs.offsetLeft + rhs.clientLeft;
                                        newTop -= rhs.offsetTop + rhs.clientTop;
                                    }
                                    return makeArea(newLeft, newTop, width, height);
                                }
                            };
                        }

                        var parent, elem = this, area = makeArea(
                            this.offsetLeft, this.offsetTop,
                            this.offsetWidth, this.offsetHeight);
                        while (tools.isElement(parent = elem.parentNode)) {
                            var clientLeft = parent.offsetLeft + parent.clientLeft;
                            var clientTop = parent.offsetTop + parent.clientTop;

                            // Make area relative to parent's client area.
                            area = area.relativeFromTo(elem, parent).translate(-clientLeft, -clientTop);

                            parent.scrollLeft = withinBounds(
                                parent.scrollLeft,
                                area.right - parent.clientWidth, area.left,
                                parent.clientWidth);

                            parent.scrollTop = withinBounds(
                                parent.scrollTop,
                                area.bottom - parent.clientHeight, area.top,
                                parent.clientHeight);

                            // Determine actual scroll amount by reading back scroll properties.
                            area = area.translate(clientLeft - parent.scrollLeft,
                                clientTop - parent.scrollTop);
                            elem = parent;
                        }
                    };
                }
                dom.scrollIntoViewIfNeeded();
            },
            setFirstNode: function (setting, parentNode) {
                var childKey = setting.data.key.children, childLength = parentNode[childKey].length;
                if (childLength > 0) {
                    parentNode[childKey][0].isFirstNode = true;
                }
            },
            setLastNode: function (setting, parentNode) {
                var childKey = setting.data.key.children, childLength = parentNode[childKey].length;
                if (childLength > 0) {
                    parentNode[childKey][childLength - 1].isLastNode = true;
                }
            },
            removeNode: function (setting, node) {
                var root = data.getRoot(setting),
                    childKey = setting.data.key.children,
                    parentNode = (node.parentTId) ? node.getParentNode() : root;

                node.isFirstNode = false;
                node.isLastNode = false;
                node.getPreNode = function () {
                    return null;
                };
                node.getNextNode = function () {
                    return null;
                };

                if (!data.getNodeCache(setting, node.tId)) {
                    return;
                }

                $$(node, setting).remove();
                data.removeNodeCache(setting, node);
                data.removeSelectedNode(setting, node);

                for (var i = 0, l = parentNode[childKey].length; i < l; i++) {
                    if (parentNode[childKey][i].tId == node.tId) {
                        parentNode[childKey].splice(i, 1);
                        break;
                    }
                }
                view.setFirstNode(setting, parentNode);
                view.setLastNode(setting, parentNode);

                var tmp_ulObj, tmp_switchObj, tmp_icoObj,
                    childLength = parentNode[childKey].length;

                //repair nodes old parent
                if (!setting.data.keep.parent && childLength == 0) {
                    //old parentNode has no child nodes
                    parentNode.isParent = false;
                    parentNode.open = false;
                    tmp_ulObj = $$(parentNode, consts.id.UL, setting);
                    tmp_switchObj = $$(parentNode, consts.id.SWITCH, setting);
                    tmp_icoObj = $$(parentNode, consts.id.ICON, setting);
                    view.replaceSwitchClass(parentNode, tmp_switchObj, consts.folder.DOCU);
                    view.replaceIcoClass(parentNode, tmp_icoObj, consts.folder.DOCU);
                    tmp_ulObj.css("display", "none");

                } else if (setting.view.showLine && childLength > 0) {
                    //old parentNode has child nodes
                    var newLast = parentNode[childKey][childLength - 1];
                    tmp_ulObj = $$(newLast, consts.id.UL, setting);
                    tmp_switchObj = $$(newLast, consts.id.SWITCH, setting);
                    tmp_icoObj = $$(newLast, consts.id.ICON, setting);
                    if (parentNode == root) {
                        if (parentNode[childKey].length == 1) {
                            //node was root, and ztree has only one root after move node
                            view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.ROOT);
                        } else {
                            var tmp_first_switchObj = $$(parentNode[childKey][0], consts.id.SWITCH, setting);
                            view.replaceSwitchClass(parentNode[childKey][0], tmp_first_switchObj, consts.line.ROOTS);
                            view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);
                        }
                    } else {
                        view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);
                    }
                    tmp_ulObj.removeClass(consts.line.LINE);
                }
            },
            replaceIcoClass: function (node, obj, newName) {
                if (!obj || node.isAjaxing) return;
                var tmpName = obj.attr("class");
                if (tmpName == undefined) return;
                var tmpList = tmpName.split("_");
                switch (newName) {
                    case consts.folder.OPEN:
                    case consts.folder.CLOSE:
                    case consts.folder.DOCU:
                        tmpList[tmpList.length - 1] = newName;
                        break;
                }
                obj.attr("class", tmpList.join("_"));
            },
            replaceSwitchClass: function (node, obj, newName) {
                if (!obj) return;
                var tmpName = obj.attr("class");
                if (tmpName == undefined) return;
                var tmpList = tmpName.split("_");
                switch (newName) {
                    case consts.line.ROOT:
                    case consts.line.ROOTS:
                    case consts.line.CENTER:
                    case consts.line.BOTTOM:
                    case consts.line.NOLINE:
                        tmpList[0] = view.makeNodeLineClassEx(node) + newName;
                        break;
                    case consts.folder.OPEN:
                    case consts.folder.CLOSE:
                    case consts.folder.DOCU:
                        tmpList[1] = newName;
                        break;
                }
                obj.attr("class", tmpList.join("_"));
                if (newName !== consts.folder.DOCU) {
                    obj.removeAttr("disabled");
                } else {
                    obj.attr("disabled", "disabled");
                }
            },
            selectNode: function (setting, node, addFlag) {
                if (!addFlag) {
                    view.cancelPreSelectedNode(setting, null, node);
                }
                $$(node, consts.id.A, setting).addClass(consts.node.CURSELECTED);
                data.addSelectedNode(setting, node);
                setting.treeObj.trigger(consts.event.SELECTED, [setting.treeId, node]);
            },
            setNodeFontCss: function (setting, treeNode) {
                var aObj = $$(treeNode, consts.id.A, setting),
                    fontCss = view.makeNodeFontCss(setting, treeNode);
                if (fontCss) {
                    aObj.css(fontCss);
                }
            },
            setNodeLineIcos: function (setting, node) {
                if (!node) return;
                var switchObj = $$(node, consts.id.SWITCH, setting),
                    ulObj = $$(node, consts.id.UL, setting),
                    icoObj = $$(node, consts.id.ICON, setting),
                    ulLine = view.makeUlLineClass(setting, node);
                if (ulLine.length == 0) {
                    ulObj.removeClass(consts.line.LINE);
                } else {
                    ulObj.addClass(ulLine);
                }
                switchObj.attr("class", view.makeNodeLineClass(setting, node));
                if (node.isParent) {
                    switchObj.removeAttr("disabled");
                } else {
                    switchObj.attr("disabled", "disabled");
                }
                icoObj.removeAttr("style");
                icoObj.attr("style", view.makeNodeIcoStyle(setting, node));
                icoObj.attr("class", view.makeNodeIcoClass(setting, node));
            },
            setNodeName: function (setting, node) {
                var title = data.getNodeTitle(setting, node),
                    nObj = $$(node, consts.id.SPAN, setting);
                nObj.empty();
                if (setting.view.nameIsHTML) {
                    nObj.html(data.getNodeName(setting, node));
                } else {
                    nObj.text(data.getNodeName(setting, node));
                }
                if (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle)) {
                    var aObj = $$(node, consts.id.A, setting);
                    aObj.attr("title", !title ? "" : title);
                }
            },
            setNodeTarget: function (setting, node) {
                var aObj = $$(node, consts.id.A, setting);
                aObj.attr("target", view.makeNodeTarget(node));
            },
            setNodeUrl: function (setting, node) {
                var aObj = $$(node, consts.id.A, setting),
                    url = view.makeNodeUrl(setting, node);
                if (url == null || url.length == 0) {
                    aObj.removeAttr("href");
                } else {
                    aObj.attr("href", url);
                }
            },
            switchNode: function (setting, node) {
                if (node.open || !tools.canAsync(setting, node)) {
                    view.expandCollapseNode(setting, node, !node.open);
                } else if (setting.async.enable) {
                    if (!view.asyncNode(setting, node)) {
                        view.expandCollapseNode(setting, node, !node.open);
                        return;
                    }
                } else if (node) {
                    view.expandCollapseNode(setting, node, !node.open);
                }
            }
        };
    // zTree defind
    $.fn.zTree = {
        consts: _consts,
        _z: {
            tools: tools,
            view: view,
            event: event,
            data: data
        },
        getZTreeObj: function (treeId) {
            var o = data.getZTreeTools(treeId);
            return o ? o : null;
        },
        destroy: function (treeId) {
            if (!!treeId && treeId.length > 0) {
                view.destroy(data.getSetting(treeId));
            } else {
                for (var s in settings) {
                    view.destroy(settings[s]);
                }
            }
        },
        init: function (obj, zSetting, zNodes) {
            var setting = tools.clone(_setting);
            $.extend(true, setting, zSetting);
            setting.treeId = obj.attr("id");
            setting.treeObj = obj;
            setting.treeObj.empty();
            settings[setting.treeId] = setting;
            //For some older browser,(e.g., ie6)
            if (typeof document.body.style.maxHeight === "undefined") {
                setting.view.expandSpeed = "";
            }
            data.initRoot(setting);
            var root = data.getRoot(setting),
                childKey = setting.data.key.children;
            zNodes = zNodes ? tools.clone(tools.isArray(zNodes) ? zNodes : [zNodes]) : [];
            if (setting.data.simpleData.enable) {
                root[childKey] = data.transformTozTreeFormat(setting, zNodes);
            } else {
                root[childKey] = zNodes;
            }

            data.initCache(setting);
            event.unbindTree(setting);
            event.bindTree(setting);
            event.unbindEvent(setting);
            event.bindEvent(setting);

            var zTreeTools = {
                setting: setting,
                addNodes: function (parentNode, index, newNodes, isSilent) {
                    if (!parentNode) parentNode = null;
                    if (parentNode && !parentNode.isParent && setting.data.keep.leaf) return null;

                    var i = parseInt(index, 10);
                    if (isNaN(i)) {
                        isSilent = !!newNodes;
                        newNodes = index;
                        index = -1;
                    } else {
                        index = i;
                    }
                    if (!newNodes) return null;


                    var xNewNodes = tools.clone(tools.isArray(newNodes) ? newNodes : [newNodes]);

                    function addCallback() {
                        view.addNodes(setting, parentNode, index, xNewNodes, (isSilent == true));
                    }

                    if (tools.canAsync(setting, parentNode)) {
                        view.asyncNode(setting, parentNode, isSilent, addCallback);
                    } else {
                        addCallback();
                    }
                    return xNewNodes;
                },
                cancelSelectedNode: function (node) {
                    view.cancelPreSelectedNode(setting, node);
                },
                destroy: function () {
                    view.destroy(setting);
                },
                expandAll: function (expandFlag) {
                    expandFlag = !!expandFlag;
                    view.expandCollapseSonNode(setting, null, expandFlag, true);
                    return expandFlag;
                },
                expandNode: function (node, expandFlag, sonSign, focus, callbackFlag) {
                    if (!node || !node.isParent) return null;
                    if (expandFlag !== true && expandFlag !== false) {
                        expandFlag = !node.open;
                    }
                    callbackFlag = !!callbackFlag;

                    if (callbackFlag && expandFlag && (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false)) {
                        return null;
                    } else if (callbackFlag && !expandFlag && (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false)) {
                        return null;
                    }
                    if (expandFlag && node.parentTId) {
                        view.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, false);
                    }
                    if (expandFlag === node.open && !sonSign) {
                        return null;
                    }

                    data.getRoot(setting).expandTriggerFlag = callbackFlag;
                    if (!tools.canAsync(setting, node) && sonSign) {
                        view.expandCollapseSonNode(setting, node, expandFlag, true, showNodeFocus);
                    } else {
                        node.open = !expandFlag;
                        view.switchNode(this.setting, node);
                        showNodeFocus();
                    }
                    return expandFlag;

                    function showNodeFocus() {

                        var a = $$(node, setting).get(0);

                        if (a && focus !== false) {

                                view.scrollIntoView(a);

                        }
                    }
                },
                expandNodeOnly: function (node, expandFlag, sonSign, focus, callbackFlag) {
                    if (!node || !node.isParent) return null;
                    if (expandFlag !== true && expandFlag !== false) {
                        expandFlag = !node.open;
                    }
                    callbackFlag = !!callbackFlag;

                    if (callbackFlag && expandFlag && (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false)) {
                        return null;
                    } else if (callbackFlag && !expandFlag && (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false)) {
                        return null;
                    }
                    if (expandFlag && node.parentTId) {
                        view.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, false);
                    }
                    if (expandFlag === node.open && !sonSign) {
                        return null;
                    }

                    data.getRoot(setting).expandTriggerFlag = callbackFlag;
                    if (!tools.canAsync(setting, node) && sonSign) {
                        view.expandCollapseSonNode(setting, node, expandFlag, true, showNodeFocus);
                    } else {
                        node.open = !expandFlag;
                        view.switchNode(this.setting, node);
                        showNodeFocus();
                    }
                    return expandFlag;

                    function showNodeFocus() {

                        var a = $$(node, setting).get(0);

                        if (a && focus !== false) {

                                view.scrollIntoView(a);

                        }
                    }
                },
                getNodes: function () {
                    return data.getNodes(setting);
                },
                getNodeByParam: function (key, value, parentNode) {
                    if (!key) return null;
                    return data.getNodeByParam(setting, parentNode ? parentNode[setting.data.key.children] : data.getNodes(setting), key, value);
                },
                getNodeByTId: function (tId) {
                    return data.getNodeCache(setting, tId);
                },
                getNodesByParam: function (key, value, parentNode) {
                    if (!key) return null;
                    return data.getNodesByParam(setting, parentNode ? parentNode[setting.data.key.children] : data.getNodes(setting), key, value);
                },
                getNodesByParamFuzzy: function (key, value, parentNode) {
                    if (!key) return null;
                    return data.getNodesByParamFuzzy(setting, parentNode ? parentNode[setting.data.key.children] : data.getNodes(setting), key, value);
                },
                getNodesByFilter: function (filter, isSingle, parentNode, invokeParam) {
                    isSingle = !!isSingle;
                    if (!filter || (typeof filter != "function")) return (isSingle ? null : []);
                    return data.getNodesByFilter(setting, parentNode ? parentNode[setting.data.key.children] : data.getNodes(setting), filter, isSingle, invokeParam);
                },
                getNodeIndex: function (node) {
                    if (!node) return null;
                    var childKey = setting.data.key.children,
                        parentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(setting);
                    for (var i = 0, l = parentNode[childKey].length; i < l; i++) {
                        if (parentNode[childKey][i] == node) return i;
                    }
                    return -1;
                },
                getSelectedNodes: function () {
                    var r = [], list = data.getRoot(setting).curSelectedList;
                    for (var i = 0, l = list.length; i < l; i++) {
                        r.push(list[i]);
                    }
                    return r;
                },
                isSelectedNode: function (node) {
                    return data.isSelectedNode(setting, node);
                },
                reAsyncChildNodes: function (parentNode, reloadType, isSilent) {
                    if (!this.setting.async.enable) return;
                    var isRoot = !parentNode;
                    if (isRoot) {
                        parentNode = data.getRoot(setting);
                    }
                    if (reloadType == "refresh") {
                        var childKey = this.setting.data.key.children;
                        for (var i = 0, l = parentNode[childKey] ? parentNode[childKey].length : 0; i < l; i++) {
                            data.removeNodeCache(setting, parentNode[childKey][i]);
                        }
                        data.removeSelectedNode(setting);
                        parentNode[childKey] = [];
                        if (isRoot) {
                            this.setting.treeObj.empty();
                        } else {
                            var ulObj = $$(parentNode, consts.id.UL, setting);
                            ulObj.empty();
                        }
                    }
                    view.asyncNode(this.setting, isRoot ? null : parentNode, !!isSilent);
                },
                refresh: function () {
                    this.setting.treeObj.empty();
                    var root = data.getRoot(setting),
                        nodes = root[setting.data.key.children]
                    data.initRoot(setting);
                    root[setting.data.key.children] = nodes
                    data.initCache(setting);
                    view.createNodes(setting, 0, root[setting.data.key.children], null, -1);
                },
                removeChildNodes: function (node) {
                    if (!node) return null;
                    var childKey = setting.data.key.children,
                        nodes = node[childKey];
                    view.removeChildNodes(setting, node);
                    return nodes ? nodes : null;
                },
                removeNode: function (node, callbackFlag) {
                    if (!node) return;
                    callbackFlag = !!callbackFlag;
                    if (callbackFlag && tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return;
                    view.removeNode(setting, node);
                    if (callbackFlag) {
                        this.setting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);
                    }
                },
                selectNode: function (node, addFlag, isSilent) {
                    if (!node) return;
                    if (tools.uCanDo(setting)) {
                        addFlag = setting.view.selectedMulti && addFlag;
                        if (node.open) {
                            view.expandCollapseParentNode(setting, node.getParentNode(), true, false, showNodeFocus);
                        } else if (!isSilent) {
                            try {
                                $$(node, setting).focus().blur();
                            } catch (e) {
                            }
                        }
                        view.selectNode(setting, node, addFlag);
                    }

                    function showNodeFocus() {
                        if (isSilent) {
                            return;
                        }
                        var a = $$(node, setting).get(0);
                        view.scrollIntoView(a);
                    }
                },
                transformTozTreeNodes: function (simpleNodes) {
                    return data.transformTozTreeFormat(setting, simpleNodes);
                },
                transformToArray: function (nodes) {
                    return data.transformToArrayFormat(setting, nodes);
                },
                updateNode: function (node, checkTypeFlag) {
                    if (!node) return;
                    var nObj = $$(node, setting);
                    if (nObj.get(0) && tools.uCanDo(setting)) {
                        view.setNodeName(setting, node);
                        view.setNodeTarget(setting, node);
                        view.setNodeUrl(setting, node);
                        view.setNodeLineIcos(setting, node);
                        view.setNodeFontCss(setting, node);
                    }
                }
            }
            root.treeTools = zTreeTools;
            data.setZTreeTools(setting, zTreeTools);

            if (root[childKey] && root[childKey].length > 0) {
                view.createNodes(setting, 0, root[childKey], null, -1);
            } else if (setting.async.enable && setting.async.url && setting.async.url !== '') {
                view.asyncNode(setting);
            }
            return zTreeTools;
        }
    };

    var zt = $.fn.zTree,
        $$ = tools.$,
        consts = zt.consts;
})(jQuery);
/*
 * JQuery zTree excheck v3.5.28
 * http://treejs.cn/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2017-01-20
 */
(function($){
    //default consts of excheck
    var _consts = {
            event: {
                CHECK: "ztree_check"
            },
            id: {
                CHECK: "_check"
            },
            checkbox: {
                STYLE: "checkbox",
                DEFAULT: "chk",
                DISABLED: "disable",
                FALSE: "false",
                TRUE: "true",
                FULL: "full",
                PART: "part",
                FOCUS: "focus"
            },
            radio: {
                STYLE: "radio",
                TYPE_ALL: "all",
                TYPE_LEVEL: "level"
            }
        },
    //default setting of excheck
        _setting = {
            check: {
                enable: false,
                autoCheckTrigger: false,
                chkStyle: _consts.checkbox.STYLE,
                nocheckInherit: false,
                chkDisabledInherit: false,
                radioType: _consts.radio.TYPE_LEVEL,
                chkboxType: {
                    "Y": "ps",
                    "N": "ps"
                }
            },
            data: {
                key: {
                    checked: "checked"
                }
            },
            callback: {
                beforeCheck:null,
                onCheck:null
            }
        },
    //default root of excheck
        _initRoot = function (setting) {
            var r = data.getRoot(setting);
            r.radioCheckedList = [];
        },
    //default cache of excheck
        _initCache = function(treeId) {},
    //default bind event of excheck
        _bindEvent = function(setting) {
            var o = setting.treeObj,
                c = consts.event;
            o.bind(c.CHECK, function (event, srcEvent, treeId, node) {
                event.srcEvent = srcEvent;
                tools.apply(setting.callback.onCheck, [event, treeId, node]);
            });
        },
        _unbindEvent = function(setting) {
            var o = setting.treeObj,
                c = consts.event;
            o.unbind(c.CHECK);
        },
    //default event proxy of excheck
        _eventProxy = function(e) {
            var target = e.target,
                setting = data.getSetting(e.data.treeId),
                tId = "", node = null,
                nodeEventType = "", treeEventType = "",
                nodeEventCallback = null, treeEventCallback = null;

            if (tools.eqs(e.type, "mouseover")) {
                if (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {
                    tId = tools.getNodeMainDom(target).id;
                    nodeEventType = "mouseoverCheck";
                }
            } else if (tools.eqs(e.type, "mouseout")) {
                if (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {
                    tId = tools.getNodeMainDom(target).id;
                    nodeEventType = "mouseoutCheck";
                }
            } else if (tools.eqs(e.type, "click")) {
                if (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {
                    tId = tools.getNodeMainDom(target).id;
                    nodeEventType = "checkNode";
                }
            }
            if (tId.length>0) {
                node = data.getNodeCache(setting, tId);
                switch (nodeEventType) {
                    case "checkNode" :
                        nodeEventCallback = _handler.onCheckNode;
                        break;
                    case "mouseoverCheck" :
                        nodeEventCallback = _handler.onMouseoverCheck;
                        break;
                    case "mouseoutCheck" :
                        nodeEventCallback = _handler.onMouseoutCheck;
                        break;
                }
            }
            var proxyResult = {
                stop: nodeEventType === "checkNode",
                node: node,
                nodeEventType: nodeEventType,
                nodeEventCallback: nodeEventCallback,
                treeEventType: treeEventType,
                treeEventCallback: treeEventCallback
            };
            return proxyResult
        },
    //default init node of excheck
        _initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
            if (!n) return;
            var checkedKey = setting.data.key.checked;
            if (typeof n[checkedKey] == "string") n[checkedKey] = tools.eqs(n[checkedKey], "true");
            n[checkedKey] = !!n[checkedKey];
            n.checkedOld = n[checkedKey];
            if (typeof n.nocheck == "string") n.nocheck = tools.eqs(n.nocheck, "true");
            n.nocheck = !!n.nocheck || (setting.check.nocheckInherit && parentNode && !!parentNode.nocheck);
            if (typeof n.chkDisabled == "string") n.chkDisabled = tools.eqs(n.chkDisabled, "true");
            n.chkDisabled = !!n.chkDisabled || (setting.check.chkDisabledInherit && parentNode && !!parentNode.chkDisabled);
            if (typeof n.halfCheck == "string") n.halfCheck = tools.eqs(n.halfCheck, "true");
            n.halfCheck = !!n.halfCheck;
            n.check_Child_State = -1;
            n.check_Focus = false;
            n.getCheckStatus = function() {return data.getCheckStatus(setting, n);};

            if (setting.check.chkStyle == consts.radio.STYLE && setting.check.radioType == consts.radio.TYPE_ALL && n[checkedKey] ) {
                var r = data.getRoot(setting);
                r.radioCheckedList.push(n);
            }
        },
    //add dom for check
        _beforeA = function(setting, node, html) {
            var checkedKey = setting.data.key.checked;
            if (setting.check.enable) {
                data.makeChkFlag(setting, node);
                html.push("<span ID='", node.tId, consts.id.CHECK, "' class='", view.makeChkClass(setting, node), "' treeNode", consts.id.CHECK, (node.nocheck === true?" style='display:none;'":""),"></span>");
            }
        },
    //update zTreeObj, add method of check
        _zTreeTools = function(setting, zTreeTools) {
            zTreeTools.checkNode = function(node, checked, checkTypeFlag, callbackFlag) {
                var checkedKey = this.setting.data.key.checked;
                if (node.chkDisabled === true) return;
                if (checked !== true && checked !== false) {
                    checked = !node[checkedKey];
                }
                callbackFlag = !!callbackFlag;

                if (node[checkedKey] === checked && !checkTypeFlag) {
                    return;
                } else if (callbackFlag && tools.apply(this.setting.callback.beforeCheck, [this.setting.treeId, node], true) == false) {
                    return;
                }
                if (tools.uCanDo(this.setting) && this.setting.check.enable && node.nocheck !== true) {
                    node[checkedKey] = checked;
                    var checkObj = $$(node, consts.id.CHECK, this.setting);
                    if (checkTypeFlag || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);
                    view.setChkClass(this.setting, checkObj, node);
                    view.repairParentChkClassWithSelf(this.setting, node);
                    if (callbackFlag) {
                        this.setting.treeObj.trigger(consts.event.CHECK, [null, this.setting.treeId, node]);
                    }
                }
            }

            zTreeTools.checkAllNodes = function(checked) {
                view.repairAllChk(this.setting, !!checked);
            }

            zTreeTools.getCheckedNodes = function(checked) {
                var childKey = this.setting.data.key.children;
                checked = (checked !== false);
                return data.getTreeCheckedNodes(this.setting, data.getRoot(this.setting)[childKey], checked);
            }

            zTreeTools.getChangeCheckedNodes = function() {
                var childKey = this.setting.data.key.children;
                return data.getTreeChangeCheckedNodes(this.setting, data.getRoot(this.setting)[childKey]);
            }

            zTreeTools.setChkDisabled = function(node, disabled, inheritParent, inheritChildren) {
                disabled = !!disabled;
                inheritParent = !!inheritParent;
                inheritChildren = !!inheritChildren;
                view.repairSonChkDisabled(this.setting, node, disabled, inheritChildren);
                view.repairParentChkDisabled(this.setting, node.getParentNode(), disabled, inheritParent);
            }

            var _updateNode = zTreeTools.updateNode;
            zTreeTools.updateNode = function(node, checkTypeFlag) {
                if (_updateNode) _updateNode.apply(zTreeTools, arguments);
                if (!node || !this.setting.check.enable) return;
                var nObj = $$(node, this.setting);
                if (nObj.get(0) && tools.uCanDo(this.setting)) {
                    var checkObj = $$(node, consts.id.CHECK, this.setting);
                    if (checkTypeFlag == true || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);
                    view.setChkClass(this.setting, checkObj, node);
                    view.repairParentChkClassWithSelf(this.setting, node);
                }
            }
        },
    //method of operate data
        _data = {
            getRadioCheckedList: function(setting) {
                var checkedList = data.getRoot(setting).radioCheckedList;
                for (var i=0, j=checkedList.length; i<j; i++) {
                    if(!data.getNodeCache(setting, checkedList[i].tId)) {
                        checkedList.splice(i, 1);
                        i--; j--;
                    }
                }
                return checkedList;
            },
            getCheckStatus: function(setting, node) {
                if (!setting.check.enable || node.nocheck || node.chkDisabled) return null;
                var checkedKey = setting.data.key.checked,
                    r = {
                        checked: node[checkedKey],
                        half: node.halfCheck ? node.halfCheck : (setting.check.chkStyle == consts.radio.STYLE ? (node.check_Child_State === 2) : (node[checkedKey] ? (node.check_Child_State > -1 && node.check_Child_State < 2) : (node.check_Child_State > 0)))
                    };
                return r;
            },
            getTreeCheckedNodes: function(setting, nodes, checked, results) {
                if (!nodes) return [];
                var childKey = setting.data.key.children,
                    checkedKey = setting.data.key.checked,
                    onlyOne = (checked && setting.check.chkStyle == consts.radio.STYLE && setting.check.radioType == consts.radio.TYPE_ALL);
                results = !results ? [] : results;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i].nocheck !== true && nodes[i].chkDisabled !== true && nodes[i][checkedKey] == checked) {
                        results.push(nodes[i]);
                        if(onlyOne) {
                            break;
                        }
                    }
                    data.getTreeCheckedNodes(setting, nodes[i][childKey], checked, results);
                    if(onlyOne && results.length > 0) {
                        break;
                    }
                }
                return results;
            },
            getTreeChangeCheckedNodes: function(setting, nodes, results) {
                if (!nodes) return [];
                var childKey = setting.data.key.children,
                    checkedKey = setting.data.key.checked;
                results = !results ? [] : results;
                for (var i = 0, l = nodes.length; i < l; i++) {
                    if (nodes[i].nocheck !== true && nodes[i].chkDisabled !== true && nodes[i][checkedKey] != nodes[i].checkedOld) {
                        results.push(nodes[i]);
                    }
                    data.getTreeChangeCheckedNodes(setting, nodes[i][childKey], results);
                }
                return results;
            },
            makeChkFlag: function(setting, node) {
                if (!node) return;
                var childKey = setting.data.key.children,
                    checkedKey = setting.data.key.checked,
                    chkFlag = -1;
                if (node[childKey]) {
                    for (var i = 0, l = node[childKey].length; i < l; i++) {
                        var cNode = node[childKey][i];
                        var tmp = -1;
                        if (setting.check.chkStyle == consts.radio.STYLE) {
                            if (cNode.nocheck === true || cNode.chkDisabled === true) {
                                tmp = cNode.check_Child_State;
                            } else if (cNode.halfCheck === true) {
                                tmp = 2;
                            } else if (cNode[checkedKey]) {
                                tmp = 2;
                            } else {
                                tmp = cNode.check_Child_State > 0 ? 2:0;
                            }
                            if (tmp == 2) {
                                chkFlag = 2; break;
                            } else if (tmp == 0){
                                chkFlag = 0;
                            }
                        } else if (setting.check.chkStyle == consts.checkbox.STYLE) {
                            if (cNode.nocheck === true || cNode.chkDisabled === true) {
                                tmp = cNode.check_Child_State;
                            } else if (cNode.halfCheck === true) {
                                tmp = 1;
                            } else if (cNode[checkedKey] ) {
                                tmp = (cNode.check_Child_State === -1 || cNode.check_Child_State === 2) ? 2 : 1;
                            } else {
                                tmp = (cNode.check_Child_State > 0) ? 1 : 0;
                            }
                            if (tmp === 1) {
                                chkFlag = 1; break;
                            } else if (tmp === 2 && chkFlag > -1 && i > 0 && tmp !== chkFlag) {
                                chkFlag = 1; break;
                            } else if (chkFlag === 2 && tmp > -1 && tmp < 2) {
                                chkFlag = 1; break;
                            } else if (tmp > -1) {
                                chkFlag = tmp;
                            }
                        }
                    }
                }
                node.check_Child_State = chkFlag;
            }
        },
    //method of event proxy
        _event = {

        },
    //method of event handler
        _handler = {
            onCheckNode: function (event, node) {
                if (node.chkDisabled === true) return false;
                var setting = data.getSetting(event.data.treeId),
                    checkedKey = setting.data.key.checked;
                if (tools.apply(setting.callback.beforeCheck, [setting.treeId, node], true) == false) return true;
                node[checkedKey] = !node[checkedKey];
                view.checkNodeRelation(setting, node);
                var checkObj = $$(node, consts.id.CHECK, setting);
                view.setChkClass(setting, checkObj, node);
                view.repairParentChkClassWithSelf(setting, node);
                setting.treeObj.trigger(consts.event.CHECK, [event, setting.treeId, node]);
                return true;
            },
            onMouseoverCheck: function(event, node) {
                if (node.chkDisabled === true) return false;
                var setting = data.getSetting(event.data.treeId),
                    checkObj = $$(node, consts.id.CHECK, setting);
                node.check_Focus = true;
                view.setChkClass(setting, checkObj, node);
                return true;
            },
            onMouseoutCheck: function(event, node) {
                if (node.chkDisabled === true) return false;
                var setting = data.getSetting(event.data.treeId),
                    checkObj = $$(node, consts.id.CHECK, setting);
                node.check_Focus = false;
                view.setChkClass(setting, checkObj, node);
                return true;
            }
        },
    //method of tools for zTree
        _tools = {

        },
    //method of operate ztree dom
        _view = {
            checkNodeRelation: function(setting, node) {
                var pNode, i, l,
                    childKey = setting.data.key.children,
                    checkedKey = setting.data.key.checked,
                    r = consts.radio;
                if (setting.check.chkStyle == r.STYLE) {
                    var checkedList = data.getRadioCheckedList(setting);
                    if (node[checkedKey]) {
                        if (setting.check.radioType == r.TYPE_ALL) {
                            for (i = checkedList.length-1; i >= 0; i--) {
                                pNode = checkedList[i];
                                if (pNode[checkedKey] && pNode != node) {
                                    pNode[checkedKey] = false;
                                    checkedList.splice(i, 1);

                                    view.setChkClass(setting, $$(pNode, consts.id.CHECK, setting), pNode);
                                    if (pNode.parentTId != node.parentTId) {
                                        view.repairParentChkClassWithSelf(setting, pNode);
                                    }
                                }
                            }
                            checkedList.push(node);
                        } else {
                            var parentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(setting);
                            for (i = 0, l = parentNode[childKey].length; i < l; i++) {
                                pNode = parentNode[childKey][i];
                                if (pNode[checkedKey] && pNode != node) {
                                    pNode[checkedKey] = false;
                                    view.setChkClass(setting, $$(pNode, consts.id.CHECK, setting), pNode);
                                }
                            }
                        }
                    } else if (setting.check.radioType == r.TYPE_ALL) {
                        for (i = 0, l = checkedList.length; i < l; i++) {
                            if (node == checkedList[i]) {
                                checkedList.splice(i, 1);
                                break;
                            }
                        }
                    }

                } else {
                    if (node[checkedKey] && (!node[childKey] || node[childKey].length==0 || setting.check.chkboxType.Y.indexOf("s") > -1)) {
                        view.setSonNodeCheckBox(setting, node, true);
                    }
                    if (!node[checkedKey] && (!node[childKey] || node[childKey].length==0 || setting.check.chkboxType.N.indexOf("s") > -1)) {
                        view.setSonNodeCheckBox(setting, node, false);
                    }
                    if (node[checkedKey] && setting.check.chkboxType.Y.indexOf("p") > -1) {
                        view.setParentNodeCheckBox(setting, node, true);
                    }
                    if (!node[checkedKey] && setting.check.chkboxType.N.indexOf("p") > -1) {
                        view.setParentNodeCheckBox(setting, node, false);
                    }
                }
            },
            makeChkClass: function(setting, node) {
                var checkedKey = setting.data.key.checked,
                    c = consts.checkbox, r = consts.radio,
                    fullStyle = "";
                if (node.chkDisabled === true) {
                    fullStyle = c.DISABLED;
                } else if (node.halfCheck) {
                    fullStyle = c.PART;
                } else if (setting.check.chkStyle == r.STYLE) {
                    fullStyle = (node.check_Child_State < 1)? c.FULL:c.PART;
                } else {
                    fullStyle = node[checkedKey] ? ((node.check_Child_State === 2 || node.check_Child_State === -1) ? c.FULL:c.PART) : ((node.check_Child_State < 1)? c.FULL:c.PART);
                }
                var chkName = setting.check.chkStyle + "_" + (node[checkedKey] ? c.TRUE : c.FALSE) + "_" + fullStyle;
                chkName = (node.check_Focus && node.chkDisabled !== true) ? chkName + "_" + c.FOCUS : chkName;
                return consts.className.BUTTON + " " + c.DEFAULT + " " + chkName;
            },
            repairAllChk: function(setting, checked) {
                if (setting.check.enable && setting.check.chkStyle === consts.checkbox.STYLE) {
                    var checkedKey = setting.data.key.checked,
                        childKey = setting.data.key.children,
                        root = data.getRoot(setting);
                    for (var i = 0, l = root[childKey].length; i<l ; i++) {
                        var node = root[childKey][i];
                        if (node.nocheck !== true && node.chkDisabled !== true) {
                            node[checkedKey] = checked;
                        }
                        view.setSonNodeCheckBox(setting, node, checked);
                    }
                }
            },
            repairChkClass: function(setting, node) {
                if (!node) return;
                data.makeChkFlag(setting, node);
                if (node.nocheck !== true) {
                    var checkObj = $$(node, consts.id.CHECK, setting);
                    view.setChkClass(setting, checkObj, node);
                }
            },
            repairParentChkClass: function(setting, node) {
                if (!node || !node.parentTId) return;
                var pNode = node.getParentNode();
                view.repairChkClass(setting, pNode);
                view.repairParentChkClass(setting, pNode);
            },
            repairParentChkClassWithSelf: function(setting, node) {
                if (!node) return;
                var childKey = setting.data.key.children;
                if (node[childKey] && node[childKey].length > 0) {
                    view.repairParentChkClass(setting, node[childKey][0]);
                } else {
                    view.repairParentChkClass(setting, node);
                }
            },
            repairSonChkDisabled: function(setting, node, chkDisabled, inherit) {
                if (!node) return;
                var childKey = setting.data.key.children;
                if (node.chkDisabled != chkDisabled) {
                    node.chkDisabled = chkDisabled;
                }
                view.repairChkClass(setting, node);
                if (node[childKey] && inherit) {
                    for (var i = 0, l = node[childKey].length; i < l; i++) {
                        var sNode = node[childKey][i];
                        view.repairSonChkDisabled(setting, sNode, chkDisabled, inherit);
                    }
                }
            },
            repairParentChkDisabled: function(setting, node, chkDisabled, inherit) {
                if (!node) return;
                if (node.chkDisabled != chkDisabled && inherit) {
                    node.chkDisabled = chkDisabled;
                }
                view.repairChkClass(setting, node);
                view.repairParentChkDisabled(setting, node.getParentNode(), chkDisabled, inherit);
            },
            setChkClass: function(setting, obj, node) {
                if (!obj) return;
                if (node.nocheck === true) {
                    obj.hide();
                } else {
                    obj.show();
                }
                obj.attr('class', view.makeChkClass(setting, node));
            },
            setParentNodeCheckBox: function(setting, node, value, srcNode) {
                var childKey = setting.data.key.children,
                    checkedKey = setting.data.key.checked,
                    checkObj = $$(node, consts.id.CHECK, setting);
                if (!srcNode) srcNode = node;
                data.makeChkFlag(setting, node);
                if (node.nocheck !== true && node.chkDisabled !== true) {
                    node[checkedKey] = value;
                    view.setChkClass(setting, checkObj, node);
                    if (setting.check.autoCheckTrigger && node != srcNode) {
                        setting.treeObj.trigger(consts.event.CHECK, [null, setting.treeId, node]);
                    }
                }
                if (node.parentTId) {
                    var pSign = true;
                    if (!value) {
                        var pNodes = node.getParentNode()[childKey];
                        for (var i = 0, l = pNodes.length; i < l; i++) {
                            if ((pNodes[i].nocheck !== true && pNodes[i].chkDisabled !== true && pNodes[i][checkedKey])
                                || ((pNodes[i].nocheck === true || pNodes[i].chkDisabled === true) && pNodes[i].check_Child_State > 0)) {
                                pSign = false;
                                break;
                            }
                        }
                    }
                    if (pSign) {
                        view.setParentNodeCheckBox(setting, node.getParentNode(), value, srcNode);
                    }
                }
            },
            setSonNodeCheckBox: function(setting, node, value, srcNode) {
                if (!node) return;
                var childKey = setting.data.key.children,
                    checkedKey = setting.data.key.checked,
                    checkObj = $$(node, consts.id.CHECK, setting);
                if (!srcNode) srcNode = node;

                var hasDisable = false;
                if (node[childKey]) {
                    for (var i = 0, l = node[childKey].length; i < l; i++) {
                        var sNode = node[childKey][i];
                        view.setSonNodeCheckBox(setting, sNode, value, srcNode);
                        if (sNode.chkDisabled === true) hasDisable = true;
                    }
                }

                if (node != data.getRoot(setting) && node.chkDisabled !== true) {
                    if (hasDisable && node.nocheck !== true) {
                        data.makeChkFlag(setting, node);
                    }
                    if (node.nocheck !== true && node.chkDisabled !== true) {
                        node[checkedKey] = value;
                        if (!hasDisable) node.check_Child_State = (node[childKey] && node[childKey].length > 0) ? (value ? 2 : 0) : -1;
                    } else {
                        node.check_Child_State = -1;
                    }
                    view.setChkClass(setting, checkObj, node);
                    if (setting.check.autoCheckTrigger && node != srcNode && node.nocheck !== true && node.chkDisabled !== true) {
                        setting.treeObj.trigger(consts.event.CHECK, [null, setting.treeId, node]);
                    }
                }

            }
        },

        _z = {
            tools: _tools,
            view: _view,
            event: _event,
            data: _data
        };
    $.extend(true, $.fn.zTree.consts, _consts);
    $.extend(true, $.fn.zTree._z, _z);

    var zt = $.fn.zTree,
        tools = zt._z.tools,
        consts = zt.consts,
        view = zt._z.view,
        data = zt._z.data,
        event = zt._z.event,
        $$ = tools.$;

    data.exSetting(_setting);
    data.addInitBind(_bindEvent);
    data.addInitUnBind(_unbindEvent);
    data.addInitCache(_initCache);
    data.addInitNode(_initNode);
    data.addInitProxy(_eventProxy, true);
    data.addInitRoot(_initRoot);
    data.addBeforeA(_beforeA);
    data.addZTreeTools(_zTreeTools);

    var _createNodes = view.createNodes;
    view.createNodes = function(setting, level, nodes, parentNode, index) {
        if (_createNodes) _createNodes.apply(view, arguments);
        if (!nodes) return;
        view.repairParentChkClassWithSelf(setting, parentNode);
    }
    var _removeNode = view.removeNode;
    view.removeNode = function(setting, node) {
        var parentNode = node.getParentNode();
        if (_removeNode) _removeNode.apply(view, arguments);
        if (!node || !parentNode) return;
        view.repairChkClass(setting, parentNode);
        view.repairParentChkClass(setting, parentNode);
    }

    var _appendNodes = view.appendNodes;
    view.appendNodes = function(setting, level, nodes, parentNode, index, initFlag, openFlag) {
        var html = "";
        if (_appendNodes) {
            html = _appendNodes.apply(view, arguments);
        }
        if (parentNode) {
            data.makeChkFlag(setting, parentNode);
        }
        return html;
    }
})(jQuery);
/*
 * JQuery zTree exedit v3.5.28
 * http://treejs.cn/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2017-01-20
 */
(function($){
    //default consts of exedit
    var _consts = {
            event: {
                DRAG: "ztree_drag",
                DROP: "ztree_drop",
                RENAME: "ztree_rename",
                DRAGMOVE:"ztree_dragmove"
            },
            id: {
                EDIT: "_edit",
                INPUT: "_input",
                REMOVE: "_remove"
            },
            move: {
                TYPE_INNER: "inner",
                TYPE_PREV: "prev",
                TYPE_NEXT: "next"
            },
            node: {
                CURSELECTED_EDIT: "curSelectedNode_Edit",
                TMPTARGET_TREE: "tmpTargetzTree",
                TMPTARGET_NODE: "tmpTargetNode"
            }
        },
    //default setting of exedit
        _setting = {
            edit: {
                enable: false,
                editNameSelectAll: false,
                showRemoveBtn: true,
                showRenameBtn: true,
                removeTitle: "remove",
                renameTitle: "rename",
                drag: {
                    autoExpandTrigger: false,
                    isCopy: true,
                    isMove: true,
                    prev: true,
                    next: true,
                    inner: true,
                    minMoveSize: 5,
                    borderMax: 10,
                    borderMin: -5,
                    maxShowNodeNum: 5,
                    autoOpenTime: 500
                }
            },
            view: {
                addHoverDom: null,
                removeHoverDom: null
            },
            callback: {
                beforeDrag:null,
                beforeDragOpen:null,
                beforeDrop:null,
                beforeEditName:null,
                beforeRename:null,
                onDrag:null,
                onDragMove:null,
                onDrop:null,
                onRename:null
            }
        },
    //default root of exedit
        _initRoot = function (setting) {
            var r = data.getRoot(setting), rs = data.getRoots();
            r.curEditNode = null;
            r.curEditInput = null;
            r.curHoverNode = null;
            r.dragFlag = 0;
            r.dragNodeShowBefore = [];
            r.dragMaskList = new Array();
            rs.showHoverDom = true;
        },
    //default cache of exedit
        _initCache = function(treeId) {},
    //default bind event of exedit
        _bindEvent = function(setting) {
            var o = setting.treeObj;
            var c = consts.event;
            o.bind(c.RENAME, function (event, treeId, treeNode, isCancel) {
                tools.apply(setting.callback.onRename, [event, treeId, treeNode, isCancel]);
            });

            o.bind(c.DRAG, function (event, srcEvent, treeId, treeNodes) {
                tools.apply(setting.callback.onDrag, [srcEvent, treeId, treeNodes]);
            });

            o.bind(c.DRAGMOVE,function(event, srcEvent, treeId, treeNodes){
                tools.apply(setting.callback.onDragMove,[srcEvent, treeId, treeNodes]);
            });

            o.bind(c.DROP, function (event, srcEvent, treeId, treeNodes, targetNode, moveType, isCopy) {
                tools.apply(setting.callback.onDrop, [srcEvent, treeId, treeNodes, targetNode, moveType, isCopy]);
            });
        },
        _unbindEvent = function(setting) {
            var o = setting.treeObj;
            var c = consts.event;
            o.unbind(c.RENAME);
            o.unbind(c.DRAG);
            o.unbind(c.DRAGMOVE);
            o.unbind(c.DROP);
        },
    //default event proxy of exedit
        _eventProxy = function(e) {
            var target = e.target,
                setting = data.getSetting(e.data.treeId),
                relatedTarget = e.relatedTarget,
                tId = "", node = null,
                nodeEventType = "", treeEventType = "",
                nodeEventCallback = null, treeEventCallback = null,
                tmp = null;

            if (tools.eqs(e.type, "mouseover")) {
                tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
                if (tmp) {
                    tId = tools.getNodeMainDom(tmp).id;
                    nodeEventType = "hoverOverNode";
                }
            } else if (tools.eqs(e.type, "mouseout")) {
                tmp = tools.getMDom(setting, relatedTarget, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
                if (!tmp) {
                    tId = "remove";
                    nodeEventType = "hoverOutNode";
                }
            } else if (tools.eqs(e.type, "mousedown")) {
                tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
                if (tmp) {
                    tId = tools.getNodeMainDom(tmp).id;
                    nodeEventType = "mousedownNode";
                }
            }
            if (tId.length>0) {
                node = data.getNodeCache(setting, tId);
                switch (nodeEventType) {
                    case "mousedownNode" :
                        nodeEventCallback = _handler.onMousedownNode;
                        break;
                    case "hoverOverNode" :
                        nodeEventCallback = _handler.onHoverOverNode;
                        break;
                    case "hoverOutNode" :
                        nodeEventCallback = _handler.onHoverOutNode;
                        break;
                }
            }
            var proxyResult = {
                stop: false,
                node: node,
                nodeEventType: nodeEventType,
                nodeEventCallback: nodeEventCallback,
                treeEventType: treeEventType,
                treeEventCallback: treeEventCallback
            };
            return proxyResult
        },
    //default init node of exedit
        _initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
            if (!n) return;
            n.isHover = false;
            n.editNameFlag = false;
        },
    //update zTreeObj, add method of edit
        _zTreeTools = function(setting, zTreeTools) {
            zTreeTools.cancelEditName = function(newName) {
                var root = data.getRoot(this.setting);
                if (!root.curEditNode) return;
                view.cancelCurEditNode(this.setting, newName?newName:null, true);
            }
            zTreeTools.copyNode = function(targetNode, node, moveType, isSilent) {
                if (!node) return null;
                if (targetNode && !targetNode.isParent && this.setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) return null;
                var _this = this,
                    newNode = tools.clone(node);
                if (!targetNode) {
                    targetNode = null;
                    moveType = consts.move.TYPE_INNER;
                }
                if (moveType == consts.move.TYPE_INNER) {
                    function copyCallback() {
                        view.addNodes(_this.setting, targetNode, -1, [newNode], isSilent);
                    }

                    if (tools.canAsync(this.setting, targetNode)) {
                        view.asyncNode(this.setting, targetNode, isSilent, copyCallback);
                    } else {
                        copyCallback();
                    }
                } else {
                    view.addNodes(this.setting, targetNode.parentNode, -1, [newNode], isSilent);
                    view.moveNode(this.setting, targetNode, newNode, moveType, false, isSilent);
                }
                return newNode;
            }
            zTreeTools.editName = function(node) {
                if (!node || !node.tId || node !== data.getNodeCache(this.setting, node.tId)) return;
                if (node.parentTId) view.expandCollapseParentNode(this.setting, node.getParentNode(), true);
                view.editNode(this.setting, node)
            }
            zTreeTools.moveNode = function(targetNode, node, moveType, isSilent) {
                if (!node) return node;
                if (targetNode && !targetNode.isParent && this.setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) {
                    return null;
                } else if (targetNode && ((node.parentTId == targetNode.tId && moveType == consts.move.TYPE_INNER) || $$(node, this.setting).find("#" + targetNode.tId).length > 0)) {
                    return null;
                } else if (!targetNode) {
                    targetNode = null;
                }
                var _this = this;
                function moveCallback() {
                    view.moveNode(_this.setting, targetNode, node, moveType, false, isSilent);
                }
                if (tools.canAsync(this.setting, targetNode) && moveType === consts.move.TYPE_INNER) {
                    view.asyncNode(this.setting, targetNode, isSilent, moveCallback);
                } else {
                    moveCallback();
                }
                return node;
            }
            zTreeTools.setEditable = function(editable) {
                this.setting.edit.enable = editable;
                return this.refresh();
            }
        },
    //method of operate data
        _data = {
            setSonNodeLevel: function(setting, parentNode, node) {
                if (!node) return;
                var childKey = setting.data.key.children;
                node.level = (parentNode)? parentNode.level + 1 : 0;
                if (!node[childKey]) return;
                for (var i = 0, l = node[childKey].length; i < l; i++) {
                    if (node[childKey][i]) data.setSonNodeLevel(setting, node, node[childKey][i]);
                }
            }
        },
    //method of event proxy
        _event = {

        },
    //method of event handler
        _handler = {
            onHoverOverNode: function(event, node) {
                var setting = data.getSetting(event.data.treeId),
                    root = data.getRoot(setting);
                if (root.curHoverNode != node) {
                    _handler.onHoverOutNode(event);
                }
                root.curHoverNode = node;
                view.addHoverDom(setting, node);
            },
            onHoverOutNode: function(event, node) {
                var setting = data.getSetting(event.data.treeId),
                    root = data.getRoot(setting);
                if (root.curHoverNode && !data.isSelectedNode(setting, root.curHoverNode)) {
                    view.removeTreeDom(setting, root.curHoverNode);
                    root.curHoverNode = null;
                }
            },
            onMousedownNode: function(eventMouseDown, _node) {
                var i,l,
                    setting = data.getSetting(eventMouseDown.data.treeId),
                    root = data.getRoot(setting), roots = data.getRoots();
                //right click can't drag & drop
                if (eventMouseDown.button == 2 || !setting.edit.enable || (!setting.edit.drag.isCopy && !setting.edit.drag.isMove)) return true;

                //input of edit node name can't drag & drop
                var target = eventMouseDown.target,
                    _nodes = data.getRoot(setting).curSelectedList,
                    nodes = [];
                if (!data.isSelectedNode(setting, _node)) {
                    nodes = [_node];
                } else {
                    for (i=0, l=_nodes.length; i<l; i++) {
                        if (_nodes[i].editNameFlag && tools.eqs(target.tagName, "input") && target.getAttribute("treeNode"+consts.id.INPUT) !== null) {
                            return true;
                        }
                        nodes.push(_nodes[i]);
                        if (nodes[0].parentTId !== _nodes[i].parentTId) {
                            nodes = [_node];
                            break;
                        }
                    }
                }

                view.editNodeBlur = true;
                view.cancelCurEditNode(setting);

                var doc = $(setting.treeObj.get(0).ownerDocument),
                    body = $(setting.treeObj.get(0).ownerDocument.body), curNode, tmpArrow, tmpTarget,
                    isOtherTree = false,
                    targetSetting = setting,
                    sourceSetting = setting,
                    preNode, nextNode,
                    preTmpTargetNodeId = null,
                    preTmpMoveType = null,
                    tmpTargetNodeId = null,
                    moveType = consts.move.TYPE_INNER,
                    mouseDownX = eventMouseDown.clientX,
                    mouseDownY = eventMouseDown.clientY,
                    startTime = (new Date()).getTime();

                if (tools.uCanDo(setting)) {
                    doc.bind("mousemove", _docMouseMove);
                }
                function _docMouseMove(event) {
                    //avoid start drag after click node
                    if (root.dragFlag == 0 && Math.abs(mouseDownX - event.clientX) < setting.edit.drag.minMoveSize
                        && Math.abs(mouseDownY - event.clientY) < setting.edit.drag.minMoveSize) {
                        return true;
                    }
                    var i, l, tmpNode, tmpDom, tmpNodes,
                        childKey = setting.data.key.children;
                    body.css("cursor", "pointer");

                    if (root.dragFlag == 0) {
                        if (tools.apply(setting.callback.beforeDrag, [setting.treeId, nodes], true) == false) {
                            _docMouseUp(event);
                            return true;
                        }

                        for (i=0, l=nodes.length; i<l; i++) {
                            if (i==0) {
                                root.dragNodeShowBefore = [];
                            }
                            tmpNode = nodes[i];
                            if (tmpNode.isParent && tmpNode.open) {
                                view.expandCollapseNode(setting, tmpNode, !tmpNode.open);
                                root.dragNodeShowBefore[tmpNode.tId] = true;
                            } else {
                                root.dragNodeShowBefore[tmpNode.tId] = false;
                            }
                        }

                        root.dragFlag = 1;
                        roots.showHoverDom = false;
                        tools.showIfameMask(setting, true);

                        //sort
                        var isOrder = true, lastIndex = -1;
                        if (nodes.length>1) {
                            var pNodes = nodes[0].parentTId ? nodes[0].getParentNode()[childKey] : data.getNodes(setting);
                            tmpNodes = [];
                            for (i=0, l=pNodes.length; i<l; i++) {
                                if (root.dragNodeShowBefore[pNodes[i].tId] !== undefined) {
                                    if (isOrder && lastIndex > -1 && (lastIndex+1) !== i) {
                                        isOrder = false;
                                    }
                                    tmpNodes.push(pNodes[i]);
                                    lastIndex = i;
                                }
                                if (nodes.length === tmpNodes.length) {
                                    nodes = tmpNodes;
                                    break;
                                }
                            }
                        }
                        if (isOrder) {
                            preNode = nodes[0].getPreNode();
                            nextNode = nodes[nodes.length-1].getNextNode();
                        }

                        //set node in selected
                        curNode = $$("<ul class='zTreeDragUL'></ul>", setting);
                        for (i=0, l=nodes.length; i<l; i++) {
                            tmpNode = nodes[i];
                            tmpNode.editNameFlag = false;
                            view.selectNode(setting, tmpNode, i>0);
                            view.removeTreeDom(setting, tmpNode);

                            if (i > setting.edit.drag.maxShowNodeNum-1) {
                                continue;
                            }

                            tmpDom = $$("<li id='"+ tmpNode.tId +"_tmp'></li>", setting);
                            tmpDom.append($$(tmpNode, consts.id.A, setting).clone());
                            tmpDom.css("padding", "0");
                            tmpDom.children("#" + tmpNode.tId + consts.id.A).removeClass(consts.node.CURSELECTED);
                            curNode.append(tmpDom);
                            if (i == setting.edit.drag.maxShowNodeNum-1) {
                                tmpDom = $$("<li id='"+ tmpNode.tId +"_moretmp'><a>  ...  </a></li>", setting);
                                curNode.append(tmpDom);
                            }
                        }
                        curNode.attr("id", nodes[0].tId + consts.id.UL + "_tmp");
                        curNode.addClass(setting.treeObj.attr("class"));
                        curNode.appendTo(body);

                        tmpArrow = $$("<span class='tmpzTreeMove_arrow'></span>", setting);
                        tmpArrow.attr("id", "zTreeMove_arrow_tmp");
                        tmpArrow.appendTo(body);

                        setting.treeObj.trigger(consts.event.DRAG, [event, setting.treeId, nodes]);
                    }

                    if (root.dragFlag == 1) {
                        if (tmpTarget && tmpArrow.attr("id") == event.target.id && tmpTargetNodeId && (event.clientX + doc.scrollLeft()+2) > ($("#" + tmpTargetNodeId + consts.id.A, tmpTarget).offset().left)) {
                            var xT = $("#" + tmpTargetNodeId + consts.id.A, tmpTarget);
                            event.target = (xT.length > 0) ? xT.get(0) : event.target;
                        } else if (tmpTarget) {
                            tmpTarget.removeClass(consts.node.TMPTARGET_TREE);
                            if (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE + "_" + consts.move.TYPE_PREV)
                                .removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_NEXT).removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_INNER);
                        }
                        tmpTarget = null;
                        tmpTargetNodeId = null;

                        //judge drag & drop in multi ztree
                        isOtherTree = false;
                        targetSetting = setting;
                        var settings = data.getSettings();
                        for (var s in settings) {
                            if (settings[s].treeId && settings[s].edit.enable && settings[s].treeId != setting.treeId
                                && (event.target.id == settings[s].treeId || $(event.target).parents("#" + settings[s].treeId).length>0)) {
                                isOtherTree = true;
                                targetSetting = settings[s];
                            }
                        }

                        var docScrollTop = doc.scrollTop(),
                            docScrollLeft = doc.scrollLeft(),
                            treeOffset = targetSetting.treeObj.offset(),
                            scrollHeight = targetSetting.treeObj.get(0).scrollHeight,
                            scrollWidth = targetSetting.treeObj.get(0).scrollWidth,
                            dTop = (event.clientY + docScrollTop - treeOffset.top),
                            dBottom = (targetSetting.treeObj.height() + treeOffset.top - event.clientY - docScrollTop),
                            dLeft = (event.clientX + docScrollLeft - treeOffset.left),
                            dRight = (targetSetting.treeObj.width() + treeOffset.left - event.clientX - docScrollLeft),
                            isTop = (dTop < setting.edit.drag.borderMax && dTop > setting.edit.drag.borderMin),
                            isBottom = (dBottom < setting.edit.drag.borderMax && dBottom > setting.edit.drag.borderMin),
                            isLeft = (dLeft < setting.edit.drag.borderMax && dLeft > setting.edit.drag.borderMin),
                            isRight = (dRight < setting.edit.drag.borderMax && dRight > setting.edit.drag.borderMin),
                            isTreeInner = dTop > setting.edit.drag.borderMin && dBottom > setting.edit.drag.borderMin && dLeft > setting.edit.drag.borderMin && dRight > setting.edit.drag.borderMin,
                            isTreeTop = (isTop && targetSetting.treeObj.scrollTop() <= 0),
                            isTreeBottom = (isBottom && (targetSetting.treeObj.scrollTop() + targetSetting.treeObj.height()+10) >= scrollHeight),
                            isTreeLeft = (isLeft && targetSetting.treeObj.scrollLeft() <= 0),
                            isTreeRight = (isRight && (targetSetting.treeObj.scrollLeft() + targetSetting.treeObj.width()+10) >= scrollWidth);

                        if (event.target && tools.isChildOrSelf(event.target, targetSetting.treeId)) {
                            //get node <li> dom
                            var targetObj = event.target;
                            while (targetObj && targetObj.tagName && !tools.eqs(targetObj.tagName, "li") && targetObj.id != targetSetting.treeId) {
                                targetObj = targetObj.parentNode;
                            }

                            var canMove = true;
                            //don't move to self or children of self
                            for (i=0, l=nodes.length; i<l; i++) {
                                tmpNode = nodes[i];
                                if (targetObj.id === tmpNode.tId) {
                                    canMove = false;
                                    break;
                                } else if ($$(tmpNode, setting).find("#" + targetObj.id).length > 0) {
                                    canMove = false;
                                    break;
                                }
                            }
                            if (canMove && event.target && tools.isChildOrSelf(event.target, targetObj.id + consts.id.A)) {
                                tmpTarget = $(targetObj);
                                tmpTargetNodeId = targetObj.id;
                            }
                        }

                        //the mouse must be in zTree
                        tmpNode = nodes[0];
                        if (isTreeInner && tools.isChildOrSelf(event.target, targetSetting.treeId)) {
                            //judge mouse move in root of ztree
                            if (!tmpTarget && (event.target.id == targetSetting.treeId || isTreeTop || isTreeBottom || isTreeLeft || isTreeRight) && (isOtherTree || (!isOtherTree && tmpNode.parentTId))) {
                                tmpTarget = targetSetting.treeObj;
                            }
                            //auto scroll top
                            if (isTop) {
                                targetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop()-10);
                            } else if (isBottom)  {
                                targetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop()+10);
                            }
                            if (isLeft) {
                                targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()-10);
                            } else if (isRight) {
                                targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()+10);
                            }
                            //auto scroll left
                            if (tmpTarget && tmpTarget != targetSetting.treeObj && tmpTarget.offset().left < targetSetting.treeObj.offset().left) {
                                targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()+ tmpTarget.offset().left - targetSetting.treeObj.offset().left);
                            }
                        }

                        curNode.css({
                            "top": (event.clientY + docScrollTop + 3) + "px",
                            "left": (event.clientX + docScrollLeft + 3) + "px"
                        });

                        var dX = 0;
                        var dY = 0;
                        if (tmpTarget && tmpTarget.attr("id")!=targetSetting.treeId) {
                            var tmpTargetNode = tmpTargetNodeId == null ? null: data.getNodeCache(targetSetting, tmpTargetNodeId),
                                isCopy = ((event.ctrlKey || event.metaKey) && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy),
                                isPrev = !!(preNode && tmpTargetNodeId === preNode.tId),
                                isNext = !!(nextNode && tmpTargetNodeId === nextNode.tId),
                                isInner = (tmpNode.parentTId && tmpNode.parentTId == tmpTargetNodeId),
                                canPrev = (isCopy || !isNext) && tools.apply(targetSetting.edit.drag.prev, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.prev),
                                canNext = (isCopy || !isPrev) && tools.apply(targetSetting.edit.drag.next, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.next),
                                canInner = (isCopy || !isInner) && !(targetSetting.data.keep.leaf && !tmpTargetNode.isParent) && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.inner);

                            function clearMove() {
                                tmpTarget = null;
                                tmpTargetNodeId = "";
                                moveType = consts.move.TYPE_INNER;
                                tmpArrow.css({
                                    "display":"none"
                                });
                                if (window.zTreeMoveTimer) {
                                    clearTimeout(window.zTreeMoveTimer);
                                    window.zTreeMoveTargetNodeTId = null
                                }
                            }
                            if (!canPrev && !canNext && !canInner) {
                                clearMove();
                            } else {
                                var tmpTargetA = $("#" + tmpTargetNodeId + consts.id.A, tmpTarget),
                                    tmpNextA = tmpTargetNode.isLastNode ? null : $("#" + tmpTargetNode.getNextNode().tId + consts.id.A, tmpTarget.next()),
                                    tmpTop = tmpTargetA.offset().top,
                                    tmpLeft = tmpTargetA.offset().left,
                                    prevPercent = canPrev ? (canInner ? 0.25 : (canNext ? 0.5 : 1) ) : -1,
                                    nextPercent = canNext ? (canInner ? 0.75 : (canPrev ? 0.5 : 0) ) : -1,
                                    dY_percent = (event.clientY + docScrollTop - tmpTop)/tmpTargetA.height();

                                if ((prevPercent==1 || dY_percent<=prevPercent && dY_percent>=-.2) && canPrev) {
                                    dX = 1 - tmpArrow.width();
                                    dY = tmpTop - tmpArrow.height()/2;
                                    moveType = consts.move.TYPE_PREV;
                                } else if ((nextPercent==0 || dY_percent>=nextPercent && dY_percent<=1.2) && canNext) {
                                    dX = 1 - tmpArrow.width();
                                    dY = (tmpNextA == null || (tmpTargetNode.isParent && tmpTargetNode.open)) ? (tmpTop + tmpTargetA.height() - tmpArrow.height()/2) : (tmpNextA.offset().top - tmpArrow.height()/2);
                                    moveType = consts.move.TYPE_NEXT;
                                } else if (canInner) {
                                    dX = 5 - tmpArrow.width();
                                    dY = tmpTop;
                                    moveType = consts.move.TYPE_INNER;
                                } else {
                                    clearMove();
                                }

                                if (tmpTarget) {
                                    tmpArrow.css({
                                        "display":"block",
                                        "top": dY + "px",
                                        "left": (tmpLeft + dX) + "px"
                                    });
                                    tmpTargetA.addClass(consts.node.TMPTARGET_NODE + "_" + moveType);

                                    if (preTmpTargetNodeId != tmpTargetNodeId || preTmpMoveType != moveType) {
                                        startTime = (new Date()).getTime();
                                    }
                                    if (tmpTargetNode && tmpTargetNode.isParent && moveType == consts.move.TYPE_INNER) {
                                        var startTimer = true;
                                        if (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId !== tmpTargetNode.tId) {
                                            clearTimeout(window.zTreeMoveTimer);
                                            window.zTreeMoveTargetNodeTId = null;
                                        } else if (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId === tmpTargetNode.tId) {
                                            startTimer = false;
                                        }
                                        if (startTimer) {
                                            window.zTreeMoveTimer = setTimeout(function() {
                                                if (moveType != consts.move.TYPE_INNER) return;
                                                if (tmpTargetNode && tmpTargetNode.isParent && !tmpTargetNode.open && (new Date()).getTime() - startTime > targetSetting.edit.drag.autoOpenTime
                                                    && tools.apply(targetSetting.callback.beforeDragOpen, [targetSetting.treeId, tmpTargetNode], true)) {
                                                    view.switchNode(targetSetting, tmpTargetNode);
                                                    if (targetSetting.edit.drag.autoExpandTrigger) {
                                                        targetSetting.treeObj.trigger(consts.event.EXPAND, [targetSetting.treeId, tmpTargetNode]);
                                                    }
                                                }
                                            }, targetSetting.edit.drag.autoOpenTime+50);
                                            window.zTreeMoveTargetNodeTId = tmpTargetNode.tId;
                                        }
                                    }
                                }
                            }
                        } else {
                            moveType = consts.move.TYPE_INNER;
                            if (tmpTarget && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, null], !!targetSetting.edit.drag.inner)) {
                                tmpTarget.addClass(consts.node.TMPTARGET_TREE);
                            } else {
                                tmpTarget = null;
                            }
                            tmpArrow.css({
                                "display":"none"
                            });
                            if (window.zTreeMoveTimer) {
                                clearTimeout(window.zTreeMoveTimer);
                                window.zTreeMoveTargetNodeTId = null;
                            }
                        }
                        preTmpTargetNodeId = tmpTargetNodeId;
                        preTmpMoveType = moveType;

                        setting.treeObj.trigger(consts.event.DRAGMOVE, [event, setting.treeId, nodes]);
                    }
                    return false;
                }

                doc.bind("mouseup", _docMouseUp);
                function _docMouseUp(event) {
                    if (window.zTreeMoveTimer) {
                        clearTimeout(window.zTreeMoveTimer);
                        window.zTreeMoveTargetNodeTId = null;
                    }
                    preTmpTargetNodeId = null;
                    preTmpMoveType = null;
                    doc.unbind("mousemove", _docMouseMove);
                    doc.unbind("mouseup", _docMouseUp);
                    doc.unbind("selectstart", _docSelect);
                    body.css("cursor", "auto");
                    if (tmpTarget) {
                        tmpTarget.removeClass(consts.node.TMPTARGET_TREE);
                        if (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE + "_" + consts.move.TYPE_PREV)
                            .removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_NEXT).removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_INNER);
                    }
                    tools.showIfameMask(setting, false);

                    roots.showHoverDom = true;
                    if (root.dragFlag == 0) return;
                    root.dragFlag = 0;

                    var i, l, tmpNode;
                    for (i=0, l=nodes.length; i<l; i++) {
                        tmpNode = nodes[i];
                        if (tmpNode.isParent && root.dragNodeShowBefore[tmpNode.tId] && !tmpNode.open) {
                            view.expandCollapseNode(setting, tmpNode, !tmpNode.open);
                            delete root.dragNodeShowBefore[tmpNode.tId];
                        }
                    }

                    if (curNode) curNode.remove();
                    if (tmpArrow) tmpArrow.remove();

                    var isCopy = ((event.ctrlKey || event.metaKey) && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy);
                    if (!isCopy && tmpTarget && tmpTargetNodeId && nodes[0].parentTId && tmpTargetNodeId==nodes[0].parentTId && moveType == consts.move.TYPE_INNER) {
                        tmpTarget = null;
                    }
                    if (tmpTarget) {
                        var dragTargetNode = tmpTargetNodeId == null ? null: data.getNodeCache(targetSetting, tmpTargetNodeId);
                        if (tools.apply(setting.callback.beforeDrop, [targetSetting.treeId, nodes, dragTargetNode, moveType, isCopy], true) == false) {
                            view.selectNodes(sourceSetting, nodes);
                            return;
                        }
                        var newNodes = isCopy ? tools.clone(nodes) : nodes;

                        function dropCallback() {
                            if (isOtherTree) {
                                if (!isCopy) {
                                    for(var i=0, l=nodes.length; i<l; i++) {
                                        view.removeNode(setting, nodes[i]);
                                    }
                                }
                                if (moveType == consts.move.TYPE_INNER) {
                                    view.addNodes(targetSetting, dragTargetNode, -1, newNodes);
                                } else {
                                    view.addNodes(targetSetting, dragTargetNode.getParentNode(), moveType == consts.move.TYPE_PREV ? dragTargetNode.getIndex() : dragTargetNode.getIndex()+1, newNodes);
                                }
                            } else {
                                if (isCopy && moveType == consts.move.TYPE_INNER) {
                                    view.addNodes(targetSetting, dragTargetNode, -1, newNodes);
                                } else if (isCopy) {
                                    view.addNodes(targetSetting, dragTargetNode.getParentNode(), moveType == consts.move.TYPE_PREV ? dragTargetNode.getIndex() : dragTargetNode.getIndex()+1, newNodes);
                                } else {
                                    if (moveType != consts.move.TYPE_NEXT) {
                                        for (i=0, l=newNodes.length; i<l; i++) {
                                            view.moveNode(targetSetting, dragTargetNode, newNodes[i], moveType, false);
                                        }
                                    } else {
                                        for (i=-1, l=newNodes.length-1; i<l; l--) {
                                            view.moveNode(targetSetting, dragTargetNode, newNodes[l], moveType, false);
                                        }
                                    }
                                }
                            }
                            view.selectNodes(targetSetting, newNodes);
                            var a = $$(newNodes[0], setting).get(0);
                            // col_tree._ids_to_find = a; //异步展开后，可以按_ids_to_find继续
                            // col_tree.tree.expandNode(a, true);
                            view.scrollIntoView(a);

                            setting.treeObj.trigger(consts.event.DROP, [event, targetSetting.treeId, newNodes, dragTargetNode, moveType, isCopy]);
                        }

                        if (moveType == consts.move.TYPE_INNER && tools.canAsync(targetSetting, dragTargetNode)) {
                            view.asyncNode(targetSetting, dragTargetNode, false, dropCallback);
                        } else {
                            dropCallback();
                        }

                    } else {
                        view.selectNodes(sourceSetting, nodes);
                        setting.treeObj.trigger(consts.event.DROP, [event, setting.treeId, nodes, null, null, null]);
                    }
                }

                doc.bind("selectstart", _docSelect);
                function _docSelect() {
                    return false;
                }

                //Avoid FireFox's Bug
                //If zTree Div CSS set 'overflow', so drag node outside of zTree, and event.target is error.
                if(eventMouseDown.preventDefault) {
                    eventMouseDown.preventDefault();
                }
                return true;
            }
        },
    //method of tools for zTree
        _tools = {
            getAbs: function (obj) {
                var oRect = obj.getBoundingClientRect(),
                    scrollTop = document.body.scrollTop+document.documentElement.scrollTop,
                    scrollLeft = document.body.scrollLeft+document.documentElement.scrollLeft;
                return [oRect.left+scrollLeft,oRect.top+scrollTop];
            },
            inputFocus: function(inputObj) {
                if (inputObj.get(0)) {
                    inputObj.focus();
                    tools.setCursorPosition(inputObj.get(0), inputObj.val().length);
                }
            },
            inputSelect: function(inputObj) {
                if (inputObj.get(0)) {
                    inputObj.focus();
                    inputObj.select();
                }
            },
            setCursorPosition: function(obj, pos){
                if(obj.setSelectionRange) {
                    obj.focus();
                    obj.setSelectionRange(pos,pos);
                } else if (obj.createTextRange) {
                    var range = obj.createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', pos);
                    range.moveStart('character', pos);
                    range.select();
                }
            },
            showIfameMask: function(setting, showSign) {
                var root = data.getRoot(setting);
                //clear full mask
                while (root.dragMaskList.length > 0) {
                    root.dragMaskList[0].remove();
                    root.dragMaskList.shift();
                }
                if (showSign) {
                    //show mask
                    var iframeList = $$("iframe", setting);
                    for (var i = 0, l = iframeList.length; i < l; i++) {
                        var obj = iframeList.get(i),
                            r = tools.getAbs(obj),
                            dragMask = $$("<div id='zTreeMask_" + i + "' class='zTreeMask' style='top:" + r[1] + "px; left:" + r[0] + "px; width:" + obj.offsetWidth + "px; height:" + obj.offsetHeight + "px;'></div>", setting);
                        dragMask.appendTo($$("body", setting));
                        root.dragMaskList.push(dragMask);
                    }
                }
            }
        },
    //method of operate ztree dom
        _view = {
            addEditBtn: function(setting, node) {
                if (node.editNameFlag || $$(node, consts.id.EDIT, setting).length > 0) {
                    return;
                }
                if (!tools.apply(setting.edit.showRenameBtn, [setting.treeId, node], setting.edit.showRenameBtn)) {
                    return;
                }
                var aObj = $$(node, consts.id.A, setting),
                    editStr = "<span class='" + consts.className.BUTTON + " edit' id='" + node.tId + consts.id.EDIT + "' title='"+tools.apply(setting.edit.renameTitle, [setting.treeId, node], setting.edit.renameTitle)+"' treeNode"+consts.id.EDIT+" style='display:none;'></span>";
                aObj.append(editStr);

                $$(node, consts.id.EDIT, setting).bind('click',
                    function() {
                        if (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeEditName, [setting.treeId, node], true) == false) return false;
                        view.editNode(setting, node);
                        return false;
                    }
                ).show();
            },
            addRemoveBtn: function(setting, node) {
                if (node.editNameFlag || $$(node, consts.id.REMOVE, setting).length > 0) {
                    return;
                }
                if (!tools.apply(setting.edit.showRemoveBtn, [setting.treeId, node], setting.edit.showRemoveBtn)) {
                    return;
                }
                var aObj = $$(node, consts.id.A, setting),
                    removeStr = "<span class='" + consts.className.BUTTON + " remove' id='" + node.tId + consts.id.REMOVE + "' title='"+tools.apply(setting.edit.removeTitle, [setting.treeId, node], setting.edit.removeTitle)+"' treeNode"+consts.id.REMOVE+" style='display:none;'></span>";
                aObj.append(removeStr);

                $$(node, consts.id.REMOVE, setting).bind('click',
                    function() {
                        if (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return false;
                        view.removeNode(setting, node);
                        setting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);
                        return false;
                    }
                ).bind('mousedown',
                    function(eventMouseDown) {
                        return true;
                    }
                ).show();
            },
            addHoverDom: function(setting, node) {
                if (data.getRoots().showHoverDom) {
                    node.isHover = true;
                    if (setting.edit.enable) {
                        view.addEditBtn(setting, node);
                        view.addRemoveBtn(setting, node);
                    }
                    tools.apply(setting.view.addHoverDom, [setting.treeId, node]);
                }
            },
            cancelCurEditNode: function (setting, forceName, isCancel) {
                var root = data.getRoot(setting),
                    nameKey = setting.data.key.name,
                    node = root.curEditNode;

                if (node) {
                    var inputObj = root.curEditInput,
                        newName = forceName ? forceName:(isCancel ? node[nameKey]: inputObj.val());
                    if (tools.apply(setting.callback.beforeRename, [setting.treeId, node, newName, isCancel], true) === false) {
                        return false;
                    }
                    node[nameKey] = newName;
                    var aObj = $$(node, consts.id.A, setting);
                    aObj.removeClass(consts.node.CURSELECTED_EDIT);
                    inputObj.unbind();
                    view.setNodeName(setting, node);
                    node.editNameFlag = false;
                    root.curEditNode = null;
                    root.curEditInput = null;
                    view.selectNode(setting, node, false);
                    setting.treeObj.trigger(consts.event.RENAME, [setting.treeId, node, isCancel]);
                }
                root.noSelection = true;
                return true;
            },
            editNode: function(setting, node) {
                var root = data.getRoot(setting);
                view.editNodeBlur = false;
                if (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {
                    setTimeout(function() {tools.inputFocus(root.curEditInput);}, 0);
                    return;
                }
                var nameKey = setting.data.key.name;
                node.editNameFlag = true;
                view.removeTreeDom(setting, node);
                view.cancelCurEditNode(setting);
                view.selectNode(setting, node, false);
                $$(node, consts.id.SPAN, setting).html("<input type=text class='rename' id='" + node.tId + consts.id.INPUT + "' treeNode" + consts.id.INPUT + " >");
                var inputObj = $$(node, consts.id.INPUT, setting);
                inputObj.attr("value", node[nameKey]);
                if (setting.edit.editNameSelectAll) {
                    tools.inputSelect(inputObj);
                } else {
                    tools.inputFocus(inputObj);
                }

                inputObj.bind('blur', function(event) {
                    if (!view.editNodeBlur) {
                        view.cancelCurEditNode(setting);
                    }
                }).bind('keydown', function(event) {
                    if (event.keyCode=="13") {
                        view.editNodeBlur = true;
                        view.cancelCurEditNode(setting);
                    } else if (event.keyCode=="27") {
                        view.cancelCurEditNode(setting, null, true);
                    }
                }).bind('click', function(event) {
                    return false;
                }).bind('dblclick', function(event) {
                    return false;
                });

                $$(node, consts.id.A, setting).addClass(consts.node.CURSELECTED_EDIT);
                root.curEditInput = inputObj;
                root.noSelection = false;
                root.curEditNode = node;
            },
            moveNode: function(setting, targetNode, node, moveType, animateFlag, isSilent) {
                var root = data.getRoot(setting),
                    childKey = setting.data.key.children;
                if (targetNode == node) return;
                if (setting.data.keep.leaf && targetNode && !targetNode.isParent && moveType == consts.move.TYPE_INNER) return;
                var oldParentNode = (node.parentTId ? node.getParentNode(): root),
                    targetNodeIsRoot = (targetNode === null || targetNode == root);
                if (targetNodeIsRoot && targetNode === null) targetNode = root;
                if (targetNodeIsRoot) moveType = consts.move.TYPE_INNER;
                var targetParentNode = (targetNode.parentTId ? targetNode.getParentNode() : root);

                if (moveType != consts.move.TYPE_PREV && moveType != consts.move.TYPE_NEXT) {
                    moveType = consts.move.TYPE_INNER;
                }

                if (moveType == consts.move.TYPE_INNER) {
                    if (targetNodeIsRoot) {
                        //parentTId of root node is null
                        node.parentTId = null;
                    } else {
                        if (!targetNode.isParent) {
                            targetNode.isParent = true;
                            targetNode.open = !!targetNode.open;
                            view.setNodeLineIcos(setting, targetNode);
                        }
                        node.parentTId = targetNode.tId;
                    }
                }

                //move node Dom
                var targetObj, target_ulObj;
                if (targetNodeIsRoot) {
                    targetObj = setting.treeObj;
                    target_ulObj = targetObj;
                } else {
                    if (!isSilent && moveType == consts.move.TYPE_INNER) {
                        view.expandCollapseNode(setting, targetNode, true, false);
                    } else if (!isSilent) {
                        view.expandCollapseNode(setting, targetNode.getParentNode(), true, false);
                    }
                    targetObj = $$(targetNode, setting);
                    target_ulObj = $$(targetNode, consts.id.UL, setting);
                    if (!!targetObj.get(0) && !target_ulObj.get(0)) {
                        var ulstr = [];
                        view.makeUlHtml(setting, targetNode, ulstr, '');
                        targetObj.append(ulstr.join(''));
                    }
                    target_ulObj = $$(targetNode, consts.id.UL, setting);
                }
                var nodeDom = $$(node, setting);
                if (!nodeDom.get(0)) {
                    nodeDom = view.appendNodes(setting, node.level, [node], null, -1, false, true).join('');
                } else if (!targetObj.get(0)) {
                    nodeDom.remove();
                }
                if (target_ulObj.get(0) && moveType == consts.move.TYPE_INNER) {
                    target_ulObj.append(nodeDom);
                } else if (targetObj.get(0) && moveType == consts.move.TYPE_PREV) {
                    targetObj.before(nodeDom);
                } else if (targetObj.get(0) && moveType == consts.move.TYPE_NEXT) {
                    targetObj.after(nodeDom);
                }

                //repair the data after move
                var i,l,
                    tmpSrcIndex = -1,
                    tmpTargetIndex = 0,
                    oldNeighbor = null,
                    newNeighbor = null,
                    oldLevel = node.level;
                if (node.isFirstNode) {
                    tmpSrcIndex = 0;
                    if (oldParentNode[childKey].length > 1 ) {
                        oldNeighbor = oldParentNode[childKey][1];
                        oldNeighbor.isFirstNode = true;
                    }
                } else if (node.isLastNode) {
                    tmpSrcIndex = oldParentNode[childKey].length -1;
                    oldNeighbor = oldParentNode[childKey][tmpSrcIndex - 1];
                    oldNeighbor.isLastNode = true;
                } else {
                    for (i = 0, l = oldParentNode[childKey].length; i < l; i++) {
                        if (oldParentNode[childKey][i].tId == node.tId) {
                            tmpSrcIndex = i;
                            break;
                        }
                    }
                }
                if (tmpSrcIndex >= 0) {
                    oldParentNode[childKey].splice(tmpSrcIndex, 1);
                }
                if (moveType != consts.move.TYPE_INNER) {
                    for (i = 0, l = targetParentNode[childKey].length; i < l; i++) {
                        if (targetParentNode[childKey][i].tId == targetNode.tId) tmpTargetIndex = i;
                    }
                }
                if (moveType == consts.move.TYPE_INNER) {
                    if (!targetNode[childKey]) targetNode[childKey] = new Array();
                    if (targetNode[childKey].length > 0) {
                        newNeighbor = targetNode[childKey][targetNode[childKey].length - 1];
                        newNeighbor.isLastNode = false;
                    }
                    targetNode[childKey].splice(targetNode[childKey].length, 0, node);
                    node.isLastNode = true;
                    node.isFirstNode = (targetNode[childKey].length == 1);
                } else if (targetNode.isFirstNode && moveType == consts.move.TYPE_PREV) {
                    targetParentNode[childKey].splice(tmpTargetIndex, 0, node);
                    newNeighbor = targetNode;
                    newNeighbor.isFirstNode = false;
                    node.parentTId = targetNode.parentTId;
                    node.isFirstNode = true;
                    node.isLastNode = false;

                } else if (targetNode.isLastNode && moveType == consts.move.TYPE_NEXT) {
                    targetParentNode[childKey].splice(tmpTargetIndex + 1, 0, node);
                    newNeighbor = targetNode;
                    newNeighbor.isLastNode = false;
                    node.parentTId = targetNode.parentTId;
                    node.isFirstNode = false;
                    node.isLastNode = true;

                } else {
                    if (moveType == consts.move.TYPE_PREV) {
                        targetParentNode[childKey].splice(tmpTargetIndex, 0, node);
                    } else {
                        targetParentNode[childKey].splice(tmpTargetIndex + 1, 0, node);
                    }
                    node.parentTId = targetNode.parentTId;
                    node.isFirstNode = false;
                    node.isLastNode = false;
                }
                data.fixPIdKeyValue(setting, node);
                data.setSonNodeLevel(setting, node.getParentNode(), node);

                //repair node what been moved
                view.setNodeLineIcos(setting, node);
                view.repairNodeLevelClass(setting, node, oldLevel)

                //repair node's old parentNode dom
                if (!setting.data.keep.parent && oldParentNode[childKey].length < 1) {
                    //old parentNode has no child nodes
                    oldParentNode.isParent = false;
                    oldParentNode.open = false;
                    var tmp_ulObj = $$(oldParentNode, consts.id.UL, setting),
                        tmp_switchObj = $$(oldParentNode, consts.id.SWITCH, setting),
                        tmp_icoObj = $$(oldParentNode, consts.id.ICON, setting);
                    view.replaceSwitchClass(oldParentNode, tmp_switchObj, consts.folder.DOCU);
                    view.replaceIcoClass(oldParentNode, tmp_icoObj, consts.folder.DOCU);
                    tmp_ulObj.css("display", "none");

                } else if (oldNeighbor) {
                    //old neigbor node
                    view.setNodeLineIcos(setting, oldNeighbor);
                }

                //new neigbor node
                if (newNeighbor) {
                    view.setNodeLineIcos(setting, newNeighbor);
                }

                //repair checkbox / radio
                if (!!setting.check && setting.check.enable && view.repairChkClass) {
                    view.repairChkClass(setting, oldParentNode);
                    view.repairParentChkClassWithSelf(setting, oldParentNode);
                    if (oldParentNode != node.parent)
                        view.repairParentChkClassWithSelf(setting, node);
                }

                //expand parents after move
                if (!isSilent) {
                    view.expandCollapseParentNode(setting, node.getParentNode(), true, animateFlag);
                }
            },
            removeEditBtn: function(setting, node) {
                $$(node, consts.id.EDIT, setting).unbind().remove();
            },
            removeRemoveBtn: function(setting, node) {
                $$(node, consts.id.REMOVE, setting).unbind().remove();
            },
            removeTreeDom: function(setting, node) {
                node.isHover = false;
                view.removeEditBtn(setting, node);
                view.removeRemoveBtn(setting, node);
                tools.apply(setting.view.removeHoverDom, [setting.treeId, node]);
            },
            repairNodeLevelClass: function(setting, node, oldLevel) {
                if (oldLevel === node.level) return;
                var liObj = $$(node, setting),
                    aObj = $$(node, consts.id.A, setting),
                    ulObj = $$(node, consts.id.UL, setting),
                    oldClass = consts.className.LEVEL + oldLevel,
                    newClass = consts.className.LEVEL + node.level;
                liObj.removeClass(oldClass);
                liObj.addClass(newClass);
                aObj.removeClass(oldClass);
                aObj.addClass(newClass);
                ulObj.removeClass(oldClass);
                ulObj.addClass(newClass);
            },
            selectNodes : function(setting, nodes) {
                for (var i=0, l=nodes.length; i<l; i++) {
                    view.selectNode(setting, nodes[i], i>0);
                }
            }
        },

        _z = {
            tools: _tools,
            view: _view,
            event: _event,
            data: _data
        };
    $.extend(true, $.fn.zTree.consts, _consts);
    $.extend(true, $.fn.zTree._z, _z);

    var zt = $.fn.zTree,
        tools = zt._z.tools,
        consts = zt.consts,
        view = zt._z.view,
        data = zt._z.data,
        event = zt._z.event,
        $$ = tools.$;

    data.exSetting(_setting);
    data.addInitBind(_bindEvent);
    data.addInitUnBind(_unbindEvent);
    data.addInitCache(_initCache);
    data.addInitNode(_initNode);
    data.addInitProxy(_eventProxy);
    data.addInitRoot(_initRoot);
    data.addZTreeTools(_zTreeTools);

    var _cancelPreSelectedNode = view.cancelPreSelectedNode;
    view.cancelPreSelectedNode = function (setting, node) {
        var list = data.getRoot(setting).curSelectedList;
        for (var i=0, j=list.length; i<j; i++) {
            if (!node || node === list[i]) {
                view.removeTreeDom(setting, list[i]);
                if (node) break;
            }
        }
        if (_cancelPreSelectedNode) _cancelPreSelectedNode.apply(view, arguments);
    }

    var _createNodes = view.createNodes;
    view.createNodes = function(setting, level, nodes, parentNode, index) {
        if (_createNodes) {
            _createNodes.apply(view, arguments);
        }
        if (!nodes) return;
        if (view.repairParentChkClassWithSelf) {
            view.repairParentChkClassWithSelf(setting, parentNode);
        }
    }

    var _makeNodeUrl = view.makeNodeUrl;
    view.makeNodeUrl = function(setting, node) {
        return setting.edit.enable ? null : (_makeNodeUrl.apply(view, arguments));
    }

    var _removeNode = view.removeNode;
    view.removeNode = function(setting, node) {
        var root = data.getRoot(setting);
        if (root.curEditNode === node) root.curEditNode = null;
        if (_removeNode) {
            _removeNode.apply(view, arguments);
        }
    }

    var _selectNode = view.selectNode;
    view.selectNode = function(setting, node, addFlag) {
        var root = data.getRoot(setting);
        if (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {
            return false;
        }
        if (_selectNode) _selectNode.apply(view, arguments);
        view.addHoverDom(setting, node);
        return true;
    }

    var _uCanDo = tools.uCanDo;
    tools.uCanDo = function(setting, e) {
        var root = data.getRoot(setting);
        if (e && (tools.eqs(e.type, "mouseover") || tools.eqs(e.type, "mouseout") || tools.eqs(e.type, "mousedown") || tools.eqs(e.type, "mouseup"))) {
            return true;
        }
        if (root.curEditNode) {
            view.editNodeBlur = false;
            root.curEditInput.focus();
        }
        return (!root.curEditNode) && (_uCanDo ? _uCanDo.apply(view, arguments) : true);
    }
})(jQuery);